<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Evil Peggle</title>
  <style>
    html,body{height:100%}
    body{margin:0;overflow:hidden;background:linear-gradient(180deg,#0a0a0f 0%, #050508 55%, #020204 100%);color:#f7edff;font:14px/1.45 "Inter", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", Helvetica, Arial}
    .wrap{display:grid;grid-template-rows:auto 1fr auto;height:100%;background:radial-gradient(circle at 50% 115%, rgba(160,24,32,.24), rgba(4,4,6,0) 65%)}
    header{display:flex;align-items:center;gap:1rem;padding:.7rem 1.2rem;background:rgba(18,18,20,.92);border-bottom:1px solid rgba(239,68,68,.45);backdrop-filter:blur(12px);box-shadow:0 18px 36px rgba(0,0,0,.45);position:sticky;top:0;z-index:20}
    header h1{margin:0;font:600 13px/1.2 "Cinzel", Trajan, serif;letter-spacing:.28em;text-transform:uppercase;color:#fde68a;text-shadow:0 0 12px rgba(239,68,68,.6)}
    header .sp{flex:1}
    .btn, select{cursor:pointer;user-select:none;border:1px solid rgba(148,163,184,.25);background:rgba(28,29,34,.88);border-radius:12px;padding:.5rem .85rem;display:inline-flex;align-items:center;gap:.5rem;color:#f9fafb;font-weight:600;letter-spacing:.02em;box-shadow:0 8px 18px rgba(0,0,0,.35);transition:background .2s ease, transform .2s ease, box-shadow .2s ease}
    .btn:hover, select:hover{background:rgba(38,39,46,.94);transform:translateY(-1px);box-shadow:0 12px 24px rgba(0,0,0,.4)}
    .btn:active{transform:translateY(1px)}
    select{appearance:none;padding-right:1.6rem;background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="7"><path fill="%23e5e7eb" d="M1 1l5 5 5-5"/></svg>');background-repeat:no-repeat;background-position:right .6rem center}
    .danger{border-color:rgba(239,68,68,.55);background:rgba(127,29,29,.9);color:#fee2e2}
    .good{border-color:rgba(248,113,113,.35);background:rgba(153,27,27,.82);color:#fee2e2}
    .row{display:flex;align-items:center;gap:.6rem}
    #menuBtn.btn-menu{border:1px solid rgba(248,113,113,.45);background:linear-gradient(135deg, rgba(38,17,20,.92), rgba(16,7,10,.96));color:#fde68a;font-family:"Cinzel",serif;letter-spacing:.18em;text-transform:uppercase;padding:.55rem 1rem;box-shadow:0 14px 32px rgba(0,0,0,.45);gap:.45rem}
    #menuBtn.btn-menu .icon{font-size:16px;color:#f87171;text-shadow:0 0 12px rgba(248,113,113,.55)}
    #menuBtn.btn-menu .label{font-size:12px}
    #menuBtn.btn-menu:hover{background:linear-gradient(135deg, rgba(54,14,22,.94), rgba(18,9,14,.98));}
    main{display:flex;align-items:center;justify-content:center;padding:0.35rem clamp(0.35rem,2vw,1rem)}

    /* CRT look */
    .stage{position:relative;display:flex;justify-content:center;align-items:center;padding:0;width:100%;max-width:960px;margin:0 auto;overflow:hidden}
    .crt{position:relative;width:100%;max-width:960px;aspect-ratio:4/3;margin:0 auto}
    .crt:before{content:"";position:absolute;inset:0;pointer-events:none;background:repeating-linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.03) 1px, transparent 1px, transparent 3px)}
    .crt:after{content:"";position:absolute;inset:0;pointer-events:none;box-shadow:inset 0 0 200px rgba(0,0,0,.82)}
    body[data-fear='3'] .crt:after{box-shadow:inset 0 0 240px rgba(185,28,28,.55)}
    body[data-fear='4'] .crt:after{box-shadow:inset 0 0 320px rgba(220,20,60,.65)}
    body[data-fear='4'] canvas{filter:saturate(1.12) contrast(1.05)}

    canvas{display:block;width:100%;height:100%;background:#060608;border:1px solid rgba(248,113,113,.25);border-radius:22px;box-shadow:0 28px 90px rgba(0,0,0,.78)}

    .hud-layer{position:absolute;inset:0;display:flex;flex-direction:column;justify-content:flex-start;padding:18px 24px 14px;pointer-events:none;color:#f9eeff;text-shadow:0 0 12px rgba(255,255,255,.12);opacity:1;transition:opacity .2s ease}
    .hud-top{display:flex;justify-content:space-between;align-items:flex-start;gap:1.2rem;flex-wrap:wrap}
    .hud-bottom{margin-top:auto;display:flex;justify-content:space-between;align-items:flex-end;gap:1.2rem;flex-wrap:wrap}
    .hud-cluster{display:flex;gap:.6rem;flex-wrap:wrap;align-items:flex-start}
    .hud-chip{min-width:60px;padding:.2rem .35rem;border-radius:8px;border:0;background:transparent;box-shadow:none;pointer-events:none}
    .hud-chip .label{display:block;font-size:10px;letter-spacing:.16em;text-transform:uppercase;color:rgba(248,113,113,.8);margin-bottom:2px;text-shadow:0 0 6px rgba(0,0,0,.6)}
    .hud-chip .value{display:block;font-size:20px;font-weight:700;color:#ffffff;text-shadow:0 0 12px rgba(0,0,0,.6)}
    .hud-progress{display:flex;flex-direction:column;gap:4px;min-width:200px}
    .hud-progress .progress-bar{position:relative;width:100%;height:16px;border-radius:999px;border:1px solid rgba(248,113,113,.35);background:rgba(15,15,20,.85);box-shadow:0 0 18px rgba(248,113,113,.18) inset,0 10px 24px rgba(0,0,0,.55)}
    .hud-progress .progress-bar::before{content:"";position:absolute;inset:2px;border-radius:999px;background:repeating-linear-gradient(90deg, rgba(248,113,113,.12) 0 26px, rgba(15,15,20,.0) 26px 32px);mix-blend-mode:screen;opacity:.65;pointer-events:none}
    .hud-progress .progress-bar>i{display:block;position:absolute;inset:2px;border-radius:999px;background:linear-gradient(90deg,#991b1b 0%,#ef4444 60%,#facc15 100%);box-shadow:0 0 16px rgba(248,113,113,.45),0 0 28px rgba(250,204,21,.32);transform-origin:left center;}
    .hud-chip.tight{min-width:64px}
    .hud-chip.wide{min-width:120px;text-align:center}

    .fear-widget{pointer-events:none;display:flex;flex-direction:column;align-items:center;gap:.35rem;padding:.35rem .6rem;border-radius:14px;border:0;background:transparent;box-shadow:none}
    .fear-widget .label{font-size:11px;letter-spacing:.26em;text-transform:uppercase;color:rgba(248,113,113,.8);text-shadow:0 0 6px rgba(0,0,0,.6)}
    .fear-widget .tier{font-size:12px;letter-spacing:.18em;text-transform:uppercase;color:#ffe4e6;text-shadow:0 0 10px rgba(0,0,0,.75)}
    .fear-widget .value{font-size:18px;font-weight:700;color:#ffffff;text-shadow:0 0 18px rgba(0,0,0,.8)}
    .fear-bar{width:min(260px,48vw);height:12px;border-radius:999px;background:rgba(12,13,16,.82);border:1px solid rgba(248,113,113,.3);overflow:hidden;position:relative;box-shadow:inset 0 0 12px rgba(0,0,0,.55)}
    .fear-bar>i{position:absolute;inset:0;background:linear-gradient(90deg,#f87171,#ef4444,#b91c1c);transform-origin:left center;transform:scaleX(0);transition:transform .25s ease}
    .fear-widget.fear-0{border-color:rgba(248,113,113,.45)}
    .fear-widget.fear-1{border-color:rgba(248,113,113,.6);box-shadow:0 18px 40px rgba(248,113,113,.28)}
    .fear-widget.fear-2{border-color:rgba(220,38,38,.65);box-shadow:0 18px 48px rgba(220,38,38,.32);background:linear-gradient(180deg, rgba(49,12,16,.96), rgba(24,10,12,.98))}
    .fear-widget.fear-3{border-color:rgba(185,28,28,.7);box-shadow:0 22px 58px rgba(185,28,28,.36);background:linear-gradient(180deg, rgba(58,10,14,.96), rgba(30,8,10,.98))}
    .fear-widget.fear-4{border-color:rgba(239,68,68,.82);box-shadow:0 28px 72px rgba(239,68,68,.45);background:linear-gradient(180deg, rgba(74,10,14,.97), rgba(32,6,8,.99))}

    .progress-stack{display:flex;flex-direction:column;align-items:center;gap:.3rem;pointer-events:none}
    .progress-stack .label{font-size:10px;letter-spacing:.24em;text-transform:uppercase;color:rgba(248,189,189,.85)}
    .progress-bar{width:min(260px,48vw);height:10px;border-radius:999px;background:rgba(22,22,28,.88);border:1px solid rgba(248,113,113,.38);overflow:hidden;position:relative;box-shadow:inset 0 0 14px rgba(0,0,0,.55)}
    .progress-bar>i{position:absolute;inset:0;background:linear-gradient(90deg,#f87171,#ef4444,#991b1b);transform-origin:left center;transform:scaleX(0);transition:transform .3s ease}

    .overlay{position:absolute;inset:0;display:grid;place-items:center;color:#fef2ff;z-index:15}
    .orientation-overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:2rem;background:rgba(10,10,12,0.9);backdrop-filter:blur(10px);color:#fef2ff;font-family:"Inter",ui-sans-serif;z-index:50;text-align:center}
    .orientation-overlay.active{display:flex}
    .orientation-card{max-width:360px;display:flex;flex-direction:column;align-items:center;gap:1.2rem;padding:1.8rem;border-radius:20px;background:rgba(24,24,32,0.85);border:1px solid rgba(248,113,113,0.28);box-shadow:0 18px 64px rgba(0,0,0,0.6)}
    .orientation-card img{width:120px;height:auto;filter:drop-shadow(0 8px 24px rgba(248,113,113,0.45))}
    .orientation-card h3{margin:0;font:600 18px/1.3 "Cinzel",serif;letter-spacing:.2em;text-transform:uppercase;color:#fecaca}
    .orientation-card p{margin:0;font-size:14px;color:#f8fafc;opacity:0.88}
    .orientation-card .flash{margin-top:.5rem}
    .menu.boot .subtitle{margin-bottom:0.6rem}
    .boot-progress{display:flex;flex-direction:column;align-items:stretch;gap:0.75rem;width:min(420px,86vw);margin:0 auto}
    .boot-tip-label{font-size:11px;letter-spacing:.2em;text-transform:uppercase;color:rgba(248,113,113,.78)}
    .boot-tip{font-size:13px;line-height:1.4;color:#f1f5f9;background:rgba(15,15,22,0.6);border:1px solid rgba(248,113,113,0.25);border-radius:14px;padding:0.9rem 1.1rem;min-height:60px;display:flex;align-items:center;justify-content:center;text-align:center}
    .boot-progress .progress-bar{width:100%;height:12px;border-radius:999px;overflow:hidden;border:1px solid rgba(248,113,113,0.35)}
    .device-carousel-wrapper{width:min(560px,84vw);display:flex;align-items:center;gap:0.5rem;margin-top:1.2rem}
    .device-nav{width:42px;height:42px;border-radius:50%;border:1px solid rgba(248,113,113,0.4);background:rgba(18,19,27,0.88);color:#f8fafc;display:grid;place-items:center;font-size:18px;cursor:pointer;transition:transform 0.2s ease, border-color 0.2s ease, background 0.2s ease}
    .device-nav:hover{transform:translateY(-2px);border-color:rgba(248,113,113,0.7);background:rgba(30,31,42,0.94)}
    .device-nav:active{transform:translateY(0)}
    .device-nav[disabled]{opacity:0.35;pointer-events:none}
    .device-carousel{display:flex;overflow-x:auto;scroll-snap-type:x mandatory;padding:0.5rem 0.35rem;gap:1.15rem;width:100%;scrollbar-width:none}
    .device-carousel::-webkit-scrollbar{display:none}
    .device-card{scroll-snap-align:center;min-width:210px;display:flex;flex-direction:column;align-items:center;gap:0.8rem;padding:1rem 1.1rem;border-radius:18px;background:rgba(15,16,22,0.82);border:1px solid transparent;transition:transform 0.25s ease,border-color 0.25s ease,background 0.25s ease;cursor:pointer;box-shadow:0 18px 44px rgba(0,0,0,0.45)}
    .device-card:hover{transform:translateY(-6px);border-color:rgba(248,113,113,0.6);background:rgba(30,31,42,0.9)}
    .device-card:active{transform:translateY(-2px)}
    .device-card.active{border-color:rgba(248,113,113,0.85);background:rgba(39,19,29,0.92);box-shadow:0 22px 52px rgba(248,113,113,0.25)}
    .device-card img{width:96px;height:auto;filter:drop-shadow(0 12px 28px rgba(13,13,20,0.7))}
    .device-card strong{font:600 14px/1.2 "Inter",ui-sans-serif;color:#f8fafc;letter-spacing:.08em;text-transform:uppercase}
    .device-card span{font-size:12px;color:rgba(226,232,240,0.82);text-align:center;line-height:1.45}
    .menu{pointer-events:auto;display:flex;flex-direction:column;align-items:center;gap:18px;background:linear-gradient(180deg, rgba(24,24,28,.92), rgba(16,16,22,.96));backdrop-filter:blur(16px);padding:34px;border:1px solid rgba(248,113,113,.38);border-radius:18px;text-align:center;box-shadow:0 24px 64px rgba(0,0,0,.62)}
    .menu.story p{max-width:520px;margin:0;color:rgba(248,202,202,.82)}
    .story-progress{font-size:11px;letter-spacing:.22em;text-transform:uppercase;color:rgba(248,113,113,.62)}
    .title{font:800 48px/1.05 "Cinzel", Trajan, serif;letter-spacing:.08em;text-transform:uppercase;text-align:center;text-shadow:0 0 22px rgba(239,68,68,.75);color:#fef2f2}
    .subtitle{opacity:.92;font-size:15px;letter-spacing:.2em;text-transform:uppercase;color:#fca5a5}
    .warn{font-size:12px;opacity:.85;color:#fca5a5;max-width:640px}
    .flash{animation:flash 1.6s infinite}
    .score-list{display:grid;gap:.45rem;margin-top:12px;width:100%;max-width:360px;max-height:200px;overflow:auto;padding-right:4px}
    .score-item{display:flex;justify-content:space-between;align-items:center;padding:.45rem .75rem;border-radius:12px;background:rgba(14,14,16,.7);border:1px solid rgba(248,113,113,.2);color:#fef2ff;font-size:13px;text-transform:uppercase;letter-spacing:.12em}
    .score-item span:last-child{font-weight:700;letter-spacing:.1em;color:#ffe4f8}
    .score-list-title{margin-top:16px;font-size:12px;letter-spacing:.24em;text-transform:uppercase;color:rgba(248,189,189,.72)}

    .score-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:16px;margin-top:20px;width:100%;max-width:480px}
    .score-card{border:1px solid rgba(248,113,113,.28);background:rgba(16,16,20,.78);color:#fef2ff;font:600 16px/1.2 "Inter", sans-serif;padding:16px;border-radius:14px;display:flex;flex-direction:column;gap:6px;cursor:pointer;transition:transform .15s ease, background .15s ease;appearance:none;text-align:left}
    .score-card span{font-size:12px;color:rgba(248,189,189,.85);font-weight:500;text-transform:uppercase;letter-spacing:.14em}
    .score-card:hover{transform:translateY(-2px);background:rgba(20,20,26,.86)}
    .admin-tools{display:flex;flex-direction:column;gap:10px}
    .menu.hint{gap:14px;padding:26px 28px;max-width:420px}
    .menu.hint p{margin:0;font-size:14px;color:#fef2f2}
    .menu.name{gap:18px;padding:28px 30px;max-width:380px}
    .menu.name input{width:100%;padding:.65rem .85rem;border-radius:12px;border:1px solid rgba(248,113,113,.35);background:rgba(18,18,22,.9);color:#fef2ff;font-size:16px;font-weight:600;letter-spacing:.08em;box-shadow:inset 0 0 14px rgba(0,0,0,.4)}
    .menu.name small{font-size:12px;color:rgba(248,189,189,.78);letter-spacing:.18em;text-transform:uppercase}

    .settings-layer{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(12,12,16,.85);backdrop-filter:blur(20px);z-index:60}
    .settings-layer[hidden]{display:none}
    .settings-panel{width:min(480px,calc(100% - 48px));max-height:calc(100% - 80px);overflow:auto;padding:34px;border-radius:24px;background:linear-gradient(180deg, rgba(20,20,26,.97), rgba(12,12,18,.99));border:1px solid rgba(248,113,113,.34);box-shadow:0 36px 90px rgba(0,0,0,.78);display:flex;flex-direction:column;gap:26px;color:#f9fafb}
    .settings-panel h2{margin:0;font:700 24px/1.1 "Cinzel", Trajan, serif;letter-spacing:.2em;text-transform:uppercase;text-align:center;color:#fde68a;text-shadow:0 0 28px rgba(248,113,113,.58)}
    .settings-panel p{margin:0;font-size:13px;color:rgba(248,189,189,.78);text-align:center}
    .settings-section{display:flex;flex-direction:column;gap:18px;padding:18px 20px;border-radius:20px;background:rgba(26,26,34,.82);border:1px solid rgba(248,113,113,.18);box-shadow:0 20px 52px rgba(0,0,0,.36)}
    .settings-section h3{margin:0;font:600 13px/1 "Inter",ui-sans-serif;letter-spacing:.24em;text-transform:uppercase;color:#fda4af}
    .settings-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:14px}
    .settings-stack{display:flex;flex-direction:column;gap:14px}
    .setting-tile{padding:14px 18px;border-radius:16px;background:rgba(32,34,40,.88);border:1px solid rgba(248,113,113,.22);display:flex;justify-content:space-between;align-items:center;gap:18px;font-size:13px}
    .setting-tile.slider{align-items:flex-end;}
    .setting-copy{display:flex;flex-direction:column;gap:6px;width:100%;text-align:left}
    .setting-copy span{font-weight:600;color:#f8fafc;letter-spacing:.05em;text-transform:uppercase;font-size:11px}
    .setting-copy small{font-size:11px;color:rgba(226,232,240,.7);letter-spacing:.02em;text-transform:none;font-weight:400}
    .setting-control{display:flex;align-items:center;justify-content:center}
    .option-wheel{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-top:6px;width:100%}
    .option-wheel button{flex:0 0 26px;height:26px;border-radius:50%;border:1px solid rgba(248,113,113,.4);background:rgba(18,19,27,.82);color:#f8fafc;font-weight:700;cursor:pointer;transition:transform .2s ease,border-color .2s ease}
    .option-wheel button[disabled]{opacity:0.3;cursor:not-allowed;border-color:rgba(148,163,184,.35)}
    .option-wheel button:hover{transform:translateY(-2px);border-color:rgba(248,113,113,.7)}
    .option-wheel button:active{transform:translateY(0)}
    .option-wheel .option-track{position:relative;flex:1;display:flex;overflow:hidden;border-radius:14px;border:1px solid rgba(248,113,113,.24);background:rgba(24,26,32,.75);box-shadow:inset 0 4px 16px rgba(0,0,0,.4);height:34px}
    .option-wheel .option-track .wheel-inner{display:flex;transition:transform .25s ease}
    .option-wheel .option-track span{flex:1;display:flex;align-items:center;justify-content:center;padding:0 8px;font-weight:600;letter-spacing:.05em;text-transform:uppercase;font-size:12px;color:#f8fafc;cursor:pointer;user-select:none;white-space:nowrap;transition:background .2s ease,color .2s ease}
    .option-wheel .option-track span:hover{background:rgba(148,163,184,.25)}
    .option-wheel .option-track span.active{background:rgba(248,113,113,.32);color:#fde68a;border-left:1px solid rgba(248,113,113,.45);border-right:1px solid rgba(248,113,113,.45);box-shadow:inset 0 0 16px rgba(248,113,113,.35)}
    .option-wheel.disabled{opacity:0.35}
    .option-wheel.disabled button{pointer-events:none}
    .option-wheel.disabled .option-track span{pointer-events:none}
    .slider-control{display:flex;align-items:center;gap:10px;min-width:180px}
    .slider-value{font-weight:600;font-size:12px;color:#fda4af;letter-spacing:.08em;text-transform:uppercase}
    .settings-panel input[type="text"]{width:100%;padding:.65rem .85rem;border-radius:12px;border:1px solid rgba(248,113,113,.38);background:rgba(14,14,20,.94);color:#ffffff;font-weight:600;letter-spacing:.05em;box-shadow:inset 0 0 14px rgba(0,0,0,.45)}
    .settings-panel input[type="range"]{appearance:none;width:160px;height:12px;border-radius:999px;background:rgba(55,65,81,.7);border:1px solid rgba(148,163,184,.35);box-shadow:inset 0 4px 12px rgba(0,0,0,.5);position:relative;overflow:hidden}
    .settings-panel input[type="range"]::-webkit-slider-thumb{appearance:none;width:20px;height:20px;border-radius:50%;background:linear-gradient(135deg,#f87171,#fb923c);box-shadow:0 6px 12px rgba(0,0,0,.45);border:1px solid rgba(254,215,170,.6)}
    .settings-panel input[type="range"]::-moz-range-thumb{width:20px;height:20px;border-radius:50%;background:linear-gradient(135deg,#f87171,#fb923c);box-shadow:0 6px 12px rgba(0,0,0,.45);border:1px solid rgba(254,215,170,.6)}
    .setting-switch{appearance:none;width:46px;height:24px;border-radius:999px;background:rgba(71,85,105,.6);border:1px solid rgba(148,163,184,.45);position:relative;transition:all .2s ease;box-shadow:inset 0 4px 10px rgba(0,0,0,.35)}
    .setting-switch::after{content:"";position:absolute;width:18px;height:18px;border-radius:50%;background:#f8fafc;top:2px;left:3px;transition:all .2s ease;box-shadow:0 6px 12px rgba(15,23,42,.35)}
    .setting-switch:checked{background:linear-gradient(90deg,#f87171,#ef4444);border-color:rgba(248,113,113,.65)}
    .setting-switch:checked::after{left:23px;background:#fff}
    .settings-panel select{width:160px;background:rgba(14,14,20,.92);border:1px solid rgba(248,113,113,.28);padding:.45rem .75rem}
    .settings-actions{display:flex;flex-wrap:wrap;gap:12px}
    .settings-actions .btn{flex:1;justify-content:center}
    .settings-actions.minor{justify-content:center}

    .jumpscare-layer{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at 50% 35%, rgba(255,255,255,.1), rgba(120,0,40,.78) 55%, rgba(0,0,0,.96));z-index:80;pointer-events:none;animation:jumpscareFlash .7s ease}
    .jumpscare-layer.active{background:radial-gradient(circle at 50% 35%, rgba(255,255,255,.16), rgba(190,0,40,.88) 48%, rgba(0,0,0,.96))}
    .jumpscare-face{position:relative;width:min(360px,70vw);height:min(360px,70vw);border-radius:50%;background:radial-gradient(circle at 50% 30%, rgba(255,210,210,.22), rgba(120,0,30,.82));box-shadow:0 0 120px rgba(255,0,90,.45) inset,0 0 80px rgba(255,120,180,.35)}
    .jumpscare-eye{position:absolute;width:32%;height:32%;border-radius:50%;background:radial-gradient(circle, #fff 0%, #f87171 45%, #111 78%);box-shadow:0 0 40px rgba(255,255,255,.45)}
    .jumpscare-eye.left{left:9%;top:28%}
    .jumpscare-eye.right{right:9%;top:28%}
    .jumpscare-eye::after{content:"";position:absolute;width:28%;height:28%;border-radius:50%;background:#fff;top:24%;left:32%;animation:jumpscareBlink .7s ease}
    .jumpscare-mouth{position:absolute;bottom:16%;width:62%;height:36%;border-radius:120px 120px 60px 60px/90px 90px 40px 40px;background:radial-gradient(circle at 50% 10%, #ffedd5 0%, #7f1d1d 55%, #1f0008 90%);box-shadow:0 -10px 40px rgba(255,255,255,.25)}
    .jumpscare-text{position:absolute;bottom:-16%;font:700 clamp(18px,4vw,28px)/1 "Cinzel", serif;letter-spacing:.32em;text-transform:uppercase;color:#fee2e2;text-shadow:0 0 20px rgba(255,0,80,.8)}
    @keyframes jumpscareFlash{0%{opacity:0}15%{opacity:1}100%{opacity:0}}
    @keyframes jumpscareBlink{0%,20%{transform:scaleY(1)}40%{transform:scaleY(0.18)}70%{transform:scaleY(1)}100%{transform:scaleY(1)}}
    body.fear-flash{animation:fearFlash .6s ease}
    @keyframes fearFlash{0%{filter:contrast(160%) saturate(160%)}100%{filter:none}}

    footer{display:flex;justify-content:space-between;align-items:center;padding:.6rem 1.6rem;border-top:1px solid rgba(239,68,68,.28);background:rgba(15,15,17,.92);backdrop-filter:blur(10px);font-size:12px;color:rgba(248,250,252,.7)}
    footer .footer-note{letter-spacing:.12em;text-transform:uppercase}

    @keyframes flash{0%,60%{opacity:.25}70%{opacity:.75}100%{opacity:.25}}

    @media (max-width: 768px){
      header{padding:.45rem .85rem;gap:.6rem}
      header h1{font-size:11px;letter-spacing:.22em}
      #menuBtn.btn-menu{padding:.45rem .8rem;letter-spacing:.12em}
      main{padding:0.2rem 0.35rem}
      footer{padding:.45rem 1rem;font-size:11px}
      .settings-panel{gap:22px;padding:28px}
      .settings-panel select{width:130px;max-width:130px}
      .slider-control{min-width:140px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Evil Peggle</h1>
      <div class="sp"></div>
      <div class="row">
        <button id="menuBtn" class="btn btn-menu" title="Backstage">
          <span class="icon">â˜°</span>
          <span class="label">Backstage</span>
        </button>
      </div>
    </header>
    <main>
      <div class="stage" id="stage">
        <div class="crt">
          <canvas id="game" width="960" height="720"></canvas>
        <div class="hud-layer" id="hudLayer">
          <div class="hud-top">
            <div class="hud-cluster">
              <div class="hud-chip tight">
                <span class="label">Level</span>
                <span class="value" id="levelLabel">1</span>
              </div>
              <div class="hud-chip tight">
                <span class="label">Balls</span>
                <span class="value" id="ballsLabel">10</span>
              </div>
              <div class="hud-chip">
                <span class="label">Score</span>
                <span class="value" id="scoreLabel">0</span>
              </div>
            </div>
            <div class="sp"></div>
            <div class="fear-widget" id="fearWidget" aria-live="polite">
              <span class="label">Fear</span>
              <span class="tier" id="fearStageLabel">Calm</span>
              <div class="fear-bar"><i id="fearFill"></i></div>
              <span class="value" id="fearLabel">0%</span>
            </div>
          </div>
          <div class="hud-bottom">
            <div class="hud-cluster">
              <div class="hud-chip">
                <span class="label">Cursed</span>
                <span class="value" id="cursedLabel">0 / 0</span>
              </div>
              <div class="hud-chip">
                <span class="label">Streak</span>
                <span class="value" id="streakLabel">0</span>
              </div>
            </div>
            <div class="hud-progress">
              <span class="label">Gate To Next</span>
              <div class="progress-bar"><i id="progressFill"></i></div>
            </div>
          </div>
        </div>
          <div class="overlay" id="uiOverlay"></div>
          <div class="orientation-overlay" id="orientationOverlay"></div>
        </div>
      </div>
    </main>
    <footer>
      <span class="footer-note">Version <span id="versionLabel">1.0</span> â€¢ Wear headphones</span>
      <span id="playerBadge">Watcher: Wanderer â€¢ Left click to fire â€¢ ESC for settings</span>
    </footer>
  </div>

  <div class="settings-layer" id="settingsModal" hidden></div>

<script>
(() => {
  // ===== Canvas & UI =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const ui = document.getElementById('uiOverlay');
  ui.style.pointerEvents = 'none';
  const orientationOverlay = document.getElementById('orientationOverlay');
  const stageEl = document.getElementById('stage');
  const crtEl = stageEl ? stageEl.querySelector('.crt') : null;
  let renderScale = 1;

  // ===== HUD refs =====
  const ballsLabel = document.getElementById('ballsLabel');
  const scoreLabel = document.getElementById('scoreLabel');
  const streakLabel = document.getElementById('streakLabel');
  const cursedLabel = document.getElementById('cursedLabel');
  const levelLabel  = document.getElementById('levelLabel');
  const fearLabel   = document.getElementById('fearLabel');
  const fearFill    = document.getElementById('fearFill');
  const fearWidget  = document.getElementById('fearWidget');
  const fearStageLabel = document.getElementById('fearStageLabel');
  const powerLabel  = document.getElementById('powerLabel');
  const hudLayer = document.getElementById('hudLayer');
  const progressFill= document.getElementById('progressFill');
  const settingsModal = document.getElementById('settingsModal');
  const playerBadge = document.getElementById('playerBadge');
  const versionLabel = document.getElementById('versionLabel');
  if(settingsModal){
    settingsModal.addEventListener('click', (e)=>{ if(e.target===settingsModal) closeSettings(); });
  }

  const SETTINGS_KEY = 'evilPeggle.settings.v1';
  const CUSTOM_LEVELS_KEY = 'evilPeggle.customLevels.v1';
  const defaultSettings = {
    playerName: 'Wanderer',
    bloodEnabled: true,
    audioEnabled: true,
    fearEffects: true,
    showTutorial: true,
    storySeen: false,
    storyCleared: false,
    storyProgress: 1,
    deviceType: null,
    quality: 'Med',
    musicVolume: 1,
    effectsVolume: 1,
    stats: { bestScores: {} }
  };
  const QUALITY_OPTIONS = ['Low','Med','High'];

  const VERSION = '1.1.0';
  const POW = { NONE:'none', ASTRAL:'astral', VOLTAIC:'voltaic', GRAVEN:'graven' };
  const FEAR_STAGES = [
    { threshold: 0, label: 'Calm', className: 'fear-0' },
    { threshold: 20, label: 'Uneasy', className: 'fear-1' },
    { threshold: 40, label: 'Dread', className: 'fear-2' },
    { threshold: 60, label: 'Panic', className: 'fear-3' },
    { threshold: 80, label: 'Nightmare', className: 'fear-4' }
  ];
  let currentFearStage = -1;
  const STREAK_MILESTONES = [2,3,5,8,12,18,25];
  let lastStreakPing = 0;
  const POW_DATA = {
    [POW.NONE]:    { short:'â€”',      label:'No Power',      color:'#e2e8f0', desc:'Standard eyeball.' },
    [POW.ASTRAL]:  { short:'Astral', label:'Astral Prism',  color:'#c4b5fd', desc:'Phase through two pegs before rebounding.' },
    [POW.VOLTAIC]: { short:'Volt',   label:'Voltaic Lash',  color:'#38bdf8', desc:'Chain lightning to nearby pegs on impact.' },
    [POW.GRAVEN]:  { short:'Graven', label:'Graven Well',   color:'#f97316', desc:'Detonate a gravity well to shatter clusters.' }
  };

  const MODE = { STORY:'story', FREEPLAY:'freeplay' };
  let gameMode = MODE.STORY;
  let freeplayLevel = 1;

  const settings = loadSettings();
  const customLevels = loadCustomLevels();
  if(!settings.stats || typeof settings.stats !== 'object') settings.stats = { bestScores:{} };
  if(!settings.stats.bestScores || typeof settings.stats.bestScores !== 'object') settings.stats.bestScores = {};
  if(typeof settings.storyCleared !== 'boolean') settings.storyCleared = false;
  if(typeof settings.adminUnlocked !== 'boolean') settings.adminUnlocked = false;
  if(typeof settings.storyProgress !== 'number' || !Number.isFinite(settings.storyProgress)) settings.storyProgress = 1;
  if(typeof settings.musicVolume !== 'number' || !Number.isFinite(settings.musicVolume)) settings.musicVolume = 1;
  if(typeof settings.effectsVolume !== 'number' || !Number.isFinite(settings.effectsVolume)) settings.effectsVolume = 1;
  settings.musicVolume = Math.min(1, Math.max(0, settings.musicVolume));
  settings.effectsVolume = Math.min(1, Math.max(0, settings.effectsVolume));
  if(versionLabel){ versionLabel.textContent = VERSION; }
  refreshPlayerBadge();
  setFearStage(getFearStage(0));
  let customSessionName = null;

  function loadSettings(){
    try{
      const raw = localStorage.getItem(SETTINGS_KEY);
      if(!raw) return { ...defaultSettings };
      const parsed = JSON.parse(raw);
      return { ...defaultSettings, ...parsed };
    } catch(err){
      console.warn('Failed to load settings', err);
      return { ...defaultSettings };
    }
  }

  function persistSettings(){
    try{ localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }
    catch(err){ console.warn('Failed to store settings', err); }
  }

  function loadCustomLevels(){
    try{
      const raw = localStorage.getItem(CUSTOM_LEVELS_KEY);
      if(!raw) return {};
      const parsed = JSON.parse(raw);
      if(parsed && typeof parsed === 'object' && !Array.isArray(parsed)) return parsed;
    } catch(err){
      console.warn('Failed to load custom levels', err);
    }
    return {};
  }

  function persistCustomLevels(){
    try{ localStorage.setItem(CUSTOM_LEVELS_KEY, JSON.stringify(customLevels)); }
    catch(err){ console.warn('Failed to store custom levels', err); }
  }

  function saveCustomLevel(name, pegs){
    const trimmed = (name||'').trim().slice(0,48) || `Custom ${Object.keys(customLevels).length+1}`;
    customLevels[trimmed] = {
      name: trimmed,
      updated: Date.now(),
      pegs: serializePegs(pegs||[])
    };
    persistCustomLevels();
    return trimmed;
  }

  function deleteCustomLevel(name){
    if(name in customLevels){
      delete customLevels[name];
      persistCustomLevels();
    }
  }

  function getCustomLevelEntries(){
    return Object.values(customLevels).map(entry => ({
      name: entry?.name || 'Custom',
      updated: entry?.updated || 0,
      pegs: entry?.pegs || []
    })).sort((a,b)=> b.updated - a.updated);
  }

  function serializeCurrentLevel(){
    return serializePegs(world.pegs || []);
  }

  function escHTML(str){
    const map = {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};
    return String(str ?? '').replace(/[&<>'"]/g, m => map[m]);
  }

  function refreshPlayerBadge(){
    if(!playerBadge) return;
    const name = (settings.playerName || '').trim() || 'Wanderer';
    playerBadge.textContent = `Player: ${name} â€¢ Left click to fire â€¢ ESC for settings`;
  }

  function stopGame(){
    world.ball = null;
    world.aim.ready = false;
    world.bucket.open = true;
    world.bucket.anim = 0;
    syncHUDVisibility();
  }

  function getBestScore(level){
    return settings.stats.bestScores[String(level)] ?? null;
  }

  function formatScore(val){
    if(val==null) return 'â€”';
    return Number(val).toLocaleString();
  }

  function recordBest(level, score){
    if(score==null || isNaN(score)) return;
    const key = String(level);
    const current = settings.stats.bestScores[key] ?? 0;
    if(score > current){
      settings.stats.bestScores[key] = score;
      persistSettings();
    }
  }

  function buildSettingsMarkup(){
    const nameVal = escHTML(settings.playerName || '');
    const qualityOpts = QUALITY_OPTIONS.map(opt => `<option ${opt===settings.quality? 'selected':''}>${opt}</option>`).join('');
    const deviceOpts = DEVICE_OPTIONS.map(opt => `<option value="${opt.id}" ${opt.id===settings.deviceType? 'selected':''}>${escHTML(opt.label)}</option>`).join('');
    const adminSection = settings.adminUnlocked ? `
      <section class="settings-section">
        <h3>Admin Tools</h3>
        <div class="settings-stack">
          <div class="setting-tile" style="flex-direction:column;align-items:stretch;gap:12px">
            <div class="setting-copy">
              <span>Secret Controls</span>
              <small>Debug utilities for testing runs.</small>
            </div>
            <div class="admin-tools" style="display:flex;flex-direction:column;gap:10px">
              <div style="display:flex;gap:8px;flex-wrap:wrap">
                <button class="btn" id="adminAddScore">+1k Score</button>
                <button class="btn" id="adminUnlockStory">Unlock Freeplay</button>
                <button class="btn" id="adminClearScores">Clear Best Scores</button>
              </div>
              <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
                <label style="letter-spacing:.08em;text-transform:uppercase;font-size:11px;color:rgba(248,189,189,.85)">Warp Level</label>
                <input type="number" id="adminLevelInput" min="1" max="${TOTAL_LEVELS}" value="${Math.min(TOTAL_LEVELS, Math.max(1, world.level))}" style="width:70px" />
                <button class="btn" id="adminWarp">Go</button>
              </div>
              <button class="btn" id="adminDisable">Disable Admin Mode</button>
            </div>
          </div>
        </div>
      </section>` : '';
    return `
      <div class="settings-panel">
        <h2>Ritual Settings</h2>
        <p>Quick tune-up for name, audio, and torment. All changes auto-save.</p>
        <section class="settings-section">
          <h3>Identity</h3>
          <div class="settings-stack">
            <div class="setting-tile">
              <div class="setting-copy">
                <span id="nameLabel">Player Sigil</span>
                <small>Used in whispers and the story interludes.</small>
              </div>
              <div class="setting-control">
                <input type="text" id="playerNameInput" maxlength="16" value="${nameVal}" aria-labelledby="nameLabel" />
              </div>
            </div>
          </div>
        </section>
        <section class="settings-section">
          <h3>Audio Mix</h3>
          <div class="settings-stack">
            <div class="setting-tile slider">
              <div class="setting-copy">
                <span id="musicLabel">Music Volume</span>
                <small>Detuned organ and mood beds.</small>
              </div>
              <div class="slider-control">
                <input type="range" id="musicVolumeSlider" min="0" max="1" step="0.05" value="${settings.musicVolume}" aria-labelledby="musicLabel">
                <span class="slider-value" id="musicVolumeValue">${Math.round(settings.musicVolume*100)}%</span>
              </div>
            </div>
            <div class="setting-tile slider">
              <div class="setting-copy">
                <span id="effectsLabel">Effects Volume</span>
                <small>Stingers, screams, and bucket hits.</small>
              </div>
              <div class="slider-control">
                <input type="range" id="effectsVolumeSlider" min="0" max="1" step="0.05" value="${settings.effectsVolume}" aria-labelledby="effectsLabel">
                <span class="slider-value" id="effectsVolumeValue">${Math.round(settings.effectsVolume*100)}%</span>
              </div>
            </div>
            <div class="setting-tile">
              <div class="setting-copy">
                <span id="audioLabel">Ambient Audio</span>
                <small>Toggle music, whispers, and procedural noise.</small>
              </div>
              <label class="setting-control" for="audioToggle">
                <input class="setting-switch" type="checkbox" id="audioToggle" ${audioEnabled? 'checked':''} aria-labelledby="audioLabel">
              </label>
            </div>
          </div>
        </section>
        <section class="settings-section">
          <h3>Atmosphere</h3>
          <div class="settings-grid">
            <div class="setting-tile">
              <div class="setting-copy">
                <span id="bloodLabel">Blood &amp; Gore</span>
                <small>Disable splatters if you need a breather.</small>
              </div>
              <label class="setting-control" for="bloodToggle">
                <input class="setting-switch" type="checkbox" id="bloodToggle" ${settings.bloodEnabled? 'checked':''} aria-labelledby="bloodLabel">
              </label>
            </div>
            <div class="setting-tile">
              <div class="setting-copy">
                <span id="fearLabel">Fear Events</span>
                <small>Hallucinations, glitches, and jumpscares.</small>
              </div>
              <label class="setting-control" for="fearToggle">
                <input class="setting-switch" type="checkbox" id="fearToggle" ${settings.fearEffects!==false? 'checked':''} aria-labelledby="fearLabel">
              </label>
            </div>
          </div>
        </section>
        <section class="settings-section">
          <h3>Interface</h3>
          <div class="settings-grid">
            <div class="setting-tile">
              <div class="setting-copy">
                <span id="deviceLabel">Device Mode</span>
                <small>Choose your hardware for tailored prompts.</small>
                <div class="option-wheel" aria-labelledby="deviceLabel">
                  <button type="button" id="devicePrevBtn" aria-label="Previous device">â—€</button>
                  <div class="option-track" id="deviceOptions"></div>
                  <button type="button" id="deviceNextBtn" aria-label="Next device">â–¶</button>
                </div>
              </div>
            </div>
            <div class="setting-tile">
              <div class="setting-copy">
                <span id="qualityLabel">Visual Quality</span>
                <small>Adjust particles, splatters, and hallucinations.</small>
                <div class="option-wheel" aria-labelledby="qualityLabel">
                  <button type="button" id="qualityPrevBtn" aria-label="Lower quality">â—€</button>
                  <div class="option-track" id="qualityOptions"></div>
                  <button type="button" id="qualityNextBtn" aria-label="Higher quality">â–¶</button>
                </div>
              </div>
            </div>
            <div class="setting-tile">
              <div class="setting-copy">
                <span id="tutorialLabel">Guided Tutorial</span>
                <small>Show hints during the first haunt.</small>
              </div>
              <label class="setting-control" for="tutorialToggle">
                <input class="setting-switch" type="checkbox" id="tutorialToggle" ${settings.showTutorial? 'checked':''} aria-labelledby="tutorialLabel">
              </label>
            </div>
          </div>
        </section>
        <section class="settings-section">
          <h3>Actions</h3>
          <div class="settings-actions">
            <button class="btn" id="modalHomeBtn">âŒ‚ Menu</button>
            <button class="btn danger" id="modalResetBtn">âŸ² Reset Level</button>
            <button class="btn" id="modalCloseBtn">âœ– Close</button>
            <button class="btn good" id="modalResumeBtn">âœ” Resume</button>
          </div>
          <div class="settings-actions minor">
            <button class="btn" id="modalGuideBtn">â„¹ How to Play</button>
            <button class="btn" id="modalForgetBtn">ðŸ—™ Forget Profile</button>
          </div>
        </section>
        ${adminSection}
      </div>`;
  }

  function wireSettingsModal(){
    const modal = settingsModal;
    const nameInput = modal.querySelector('#playerNameInput');
    const musicSlider = modal.querySelector('#musicVolumeSlider');
    const musicValue = modal.querySelector('#musicVolumeValue');
    const effectsSlider = modal.querySelector('#effectsVolumeSlider');
    const effectsValue = modal.querySelector('#effectsVolumeValue');
    const bloodToggle = modal.querySelector('#bloodToggle');
    const fearToggle = modal.querySelector('#fearToggle');
    const audioToggle = modal.querySelector('#audioToggle');
    const tutorialToggle = modal.querySelector('#tutorialToggle');
    const deviceTrack = modal.querySelector('#deviceOptions');
    const devicePrevBtn = modal.querySelector('#devicePrevBtn');
    const deviceNextBtn = modal.querySelector('#deviceNextBtn');
    const qualityTrack = modal.querySelector('#qualityOptions');
    const qualityPrevBtn = modal.querySelector('#qualityPrevBtn');
    const qualityNextBtn = modal.querySelector('#qualityNextBtn');
    const homeButton = modal.querySelector('#modalHomeBtn');
    const resetButton = modal.querySelector('#modalResetBtn');
    const closeButton = modal.querySelector('#modalCloseBtn');
    const resumeButton = modal.querySelector('#modalResumeBtn');
    const storyButton = modal.querySelector('#modalGuideBtn');
    const forgetButton = modal.querySelector('#modalForgetBtn');
    const adminAdd = modal.querySelector('#adminAddScore');
    const adminUnlock = modal.querySelector('#adminUnlockStory');
    const adminClear = modal.querySelector('#adminClearScores');
    const adminWarp = modal.querySelector('#adminWarp');
    const adminLevelInput = modal.querySelector('#adminLevelInput');
    const adminDisable = modal.querySelector('#adminDisable');

    const sanitizeName = val => val.replace(/[^a-z0-9 _!\-]/gi, '').slice(0, 16);
    const clamp01 = v => Math.min(1, Math.max(0, v));
    const updateRangeFill = (input) => {
      if(!input) return;
      const min = Number(input.min || 0);
      const max = Number(input.max || 1);
      const val = Number(input.value || 0);
      const pct = max === min ? 0 : ((val - min) / (max - min)) * 100;
      input.style.background = `linear-gradient(90deg, rgba(248,113,113,0.85) ${pct}%, rgba(55,65,81,0.7) ${pct}%)`;
    };

    if(nameInput){
      nameInput.addEventListener('input', e => {
        settings.playerName = sanitizeName(e.target.value);
        e.target.value = settings.playerName;
        persistSettings();
        refreshPlayerBadge();
      });
    }
    if(bloodToggle){
      bloodToggle.addEventListener('change', e => {
        settings.bloodEnabled = e.target.checked;
        persistSettings();
        if(!settings.bloodEnabled) clearBlood();
      });
    }
    if(fearToggle){
      fearToggle.addEventListener('change', e => {
        settings.fearEffects = e.target.checked;
        persistSettings();
      });
    }
    if(audioToggle){
      audioToggle.addEventListener('change', e => {
        setAudio(e.target.checked, false);
      });
    }
    if(tutorialToggle){
      tutorialToggle.addEventListener('change', e => {
        settings.showTutorial = e.target.checked;
        if(e.target.checked) tutorialShown = false;
        persistSettings();
      });
    }
    const deviceOptionIds = DEVICE_OPTIONS.map(opt => opt.id);
    const centerWheel = (track, index) => {
      const inner = track.querySelector('.wheel-inner');
      if(!inner) return;
      const spans = [...inner.children];
      if(!spans.length) return;
      const width = track.clientWidth || 1;
      const spanWidth = spans[0].clientWidth || (width / spans.length);
      const safeIndex = Math.max(0, Math.min(spans.length-1, index));
      const offset = safeIndex * spanWidth;
      const target = offset - (width - spanWidth)/2;
      inner.style.transform = `translateX(${-target}px)`;
    };
    const deviceLocked = state !== STATE.MENU;
    const renderDeviceOptions = () => {
      if(!deviceTrack) return;
      if(!DEVICE_OPTIONS.some(opt => opt.id === settings.deviceType)){
        settings.deviceType = DEVICE_OPTIONS[0]?.id || 'laptop';
        persistSettings();
      }
      const inner = DEVICE_OPTIONS.map(opt => `<span data-id="${opt.id}" class="${opt.id===settings.deviceType? 'active':''}">${escHTML(opt.label)}</span>`).join('');
      deviceTrack.innerHTML = `<div class="wheel-inner">${inner}</div>`;
      if(deviceLocked){ deviceTrack.closest('.option-wheel')?.classList.add('disabled'); }
      else { deviceTrack.closest('.option-wheel')?.classList.remove('disabled'); }
      centerWheel(deviceTrack, DEVICE_OPTIONS.findIndex(opt=>opt.id===settings.deviceType));
    };
    const cycleDevice = (dir) => {
      const idx = Math.max(0, deviceOptionIds.indexOf(settings.deviceType));
      const nextIdx = (idx + dir + deviceOptionIds.length) % deviceOptionIds.length;
      settings.deviceType = deviceOptionIds[nextIdx];
      persistSettings();
      renderDeviceOptions();
      checkOrientationLock();
    };
    renderDeviceOptions();
    if(deviceTrack){
      deviceTrack.addEventListener('click', e => {
        const span = e.target.closest('span[data-id]');
        if(!span) return;
        const id = span.dataset.id;
        if(id && DEVICE_OPTIONS.some(opt=>opt.id===id)){
          settings.deviceType = id;
          persistSettings();
          renderDeviceOptions();
          checkOrientationLock();
        }
      });
    }
    if(!deviceLocked){
      devicePrevBtn?.addEventListener('click', () => cycleDevice(-1));
      deviceNextBtn?.addEventListener('click', () => cycleDevice(1));
    } else {
      devicePrevBtn?.setAttribute('disabled','true');
      deviceNextBtn?.setAttribute('disabled','true');
    }

    const qualityOptions = QUALITY_OPTIONS.slice();
    const qualityLocked = state !== STATE.MENU;
    const renderQualityOptions = () => {
      if(!qualityTrack) return;
      if(!qualityOptions.includes(settings.quality)){
        settings.quality = 'Med';
      }
      const inner = qualityOptions.map(opt => `<span data-quality="${opt}" class="${opt===settings.quality? 'active':''}">${escHTML(opt)}</span>`).join('');
      qualityTrack.innerHTML = `<div class="wheel-inner">${inner}</div>`;
      if(qualityLocked){ qualityTrack.closest('.option-wheel')?.classList.add('disabled'); }
      else { qualityTrack.closest('.option-wheel')?.classList.remove('disabled'); }
      centerWheel(qualityTrack, qualityOptions.indexOf(settings.quality));
    };
    const cycleQuality = (dir) => {
      const idx = Math.max(0, qualityOptions.indexOf(settings.quality));
      const nextIdx = (idx + dir + qualityOptions.length) % qualityOptions.length;
      const value = qualityOptions[nextIdx];
      applyQuality(value);
      renderQualityOptions();
    };
    renderQualityOptions();
    if(!qualityLocked){
      qualityTrack?.addEventListener('click', e => {
        const span = e.target.closest('span[data-quality]');
        if(!span) return;
        const value = span.dataset.quality;
        if(value){
          applyQuality(value);
          renderQualityOptions();
        }
      });
      qualityPrevBtn?.addEventListener('click', () => cycleQuality(-1));
      qualityNextBtn?.addEventListener('click', () => cycleQuality(1));
    } else {
      qualityPrevBtn?.setAttribute('disabled','true');
      qualityNextBtn?.setAttribute('disabled','true');
    }
    if(homeButton){
    homeButton.addEventListener('click', () => {
        closeSettings();
        startMenu();
      });
    }
    if(resetButton){
      resetButton.addEventListener('click', () => {
        doResetLevel();
      });
    }
    if(closeButton){ closeButton.addEventListener('click', closeSettings); }
    if(resumeButton){ resumeButton.addEventListener('click', closeSettings); }
    if(storyButton){
      storyButton.addEventListener('click', () => {
        const resumeState = state;
        closeSettings();
        const restore = () => {
          if(resumeState === STATE.PLAY){ state = STATE.PLAY; setOverlay(''); }
          else { startMenu(); }
        };
        showStoryIntro({ markSeen:false, onComplete:restore });
      });
    }
    if(forgetButton){
      forgetButton.addEventListener('click', () => {
        localStorage.removeItem(SETTINGS_KEY);
        Object.assign(settings, { ...defaultSettings });
        applyQuality(settings.quality);
        setAudio(settings.audioEnabled, false);
        persistSettings();
        refreshPlayerBadge();
        renderSettingsModal();
      });
    }
    if(adminAdd){
      adminAdd.addEventListener('click', () => {
        world.score += 1000;
        updateHUD();
      });
    }
    if(adminUnlock){
      adminUnlock.addEventListener('click', () => {
        settings.storyCleared = true;
        persistSettings();
        closeSettings();
        startMenu();
      });
    }
    if(adminClear){
      adminClear.addEventListener('click', () => {
        settings.stats.bestScores = {};
        persistSettings();
        renderSettingsModal();
      });
    }
    if(adminWarp){
      adminWarp.addEventListener('click', () => {
        const target = parseInt(adminLevelInput?.value||'1', 10);
        if(Number.isFinite(target) && target>=1 && target<=TOTAL_LEVELS){
          closeSettings();
          if(state !== STATE.PLAY){ startGame(); }
          world.score = 0;
          loadLevel(target);
          updateHUD();
          world.aim.ready = true;
        }
      });
    }
    if(adminDisable){
      adminDisable.addEventListener('click', () => {
        settings.adminUnlocked = false;
        persistSettings();
        showFloat('Admin tools disabled', W/2, H/2, { color:'#f87171', glow:'#dc2626', duration:90, rise:0, scale:1.1 });
        renderSettingsModal();
      });
    }
  }

  function renderSettingsModal(){
    settingsModal.innerHTML = buildSettingsMarkup();
    wireSettingsModal();
  }

  function openSettings(){
    if(settingsOpen) return;
    settingsOpen = true;
    stateBeforePause = state;
    if(state === STATE.PLAY){
      state = STATE.PAUSE;
    }
    settingsModal.hidden = false;
    renderSettingsModal();
    syncHUDVisibility();
  }

  function closeSettings(){
    if(!settingsOpen) return;
    settingsModal.hidden = true;
    settingsModal.innerHTML = '';
    settingsOpen = false;
    const previous = stateBeforePause;
    state = previous;
    syncHUDVisibility();
  }

  function doResetLevel(){
    if(state === STATE.PLAY || state === STATE.PAUSE){
      loadLevel(world.level);
      updateHUD();
      stateBeforePause = STATE.PLAY;
      closeSettings();
    } else if(state === STATE.GAMEOVER){
      world.score = 0;
      world.level = 1;
      loadLevel(1);
      updateHUD();
      stateBeforePause = STATE.PLAY;
      closeSettings();
    } else if(state === STATE.MENU){
      stateBeforePause = STATE.PLAY;
      closeSettings();
      startGame();
    } else {
      closeSettings();
    }
  }

  // ===== Controls =====
  const muteBtn = document.getElementById('muteBtn');
  const menuBtn = document.getElementById('menuBtn');
  if(menuBtn){ menuBtn.onclick = () => openSettings(); }

  // ===== Quality toggle =====
  const quality = { mul: 1, particleDensity: 1, hallucinationRate: 1 };
  function applyQuality(newQuality){
      const q = newQuality || settings.quality || 'Med';
      let mul = 1;
      let particleDensity = 1;
      let hallucinationRate = 1;
      switch(q){
        case 'Low':
          mul = 0.6;
          particleDensity = 0.45;
          hallucinationRate = 0.5;
          break;
        case 'High':
          mul = 1.6;
          particleDensity = 1.2;
          hallucinationRate = 1.3;
          break;
        default:
          mul = 1;
          particleDensity = 1;
          hallucinationRate = 1;
      }
      quality.mul = mul;
      quality.particleDensity = particleDensity;
      quality.hallucinationRate = hallucinationRate;
      settings.quality = q;
      persistSettings();
    }
  applyQuality(settings.quality);

  // ===== Audio (procedural) =====
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let ac; let audioEnabled = settings.audioEnabled !== false;
  let musicGain = null;
  let musicInterval = null;
  function ensureAudio(){ if(!ac){ ac = new AudioCtx(); startMusic(); }}
  function tone(freq=200, dur=0.06, type='square', gain=0.02){ if(!audioEnabled) return; ensureAudio(); const o=ac.createOscillator(); const g=ac.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=gain * settings.effectsVolume; o.connect(g); g.connect(ac.destination); o.start(); o.stop(ac.currentTime+dur); }
  function noise(ms=100, vol=.12){ if(!audioEnabled) return; ensureAudio(); const n=ac.createBuffer(1, ac.sampleRate*ms/1000, ac.sampleRate); const d=n.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*(1-i/d.length); const s=ac.createBufferSource(); s.buffer=n; const g=ac.createGain(); g.gain.value=vol * settings.effectsVolume; s.connect(g); g.connect(ac.destination); s.start(); }
  function sting(){ if(!audioEnabled) return; ensureAudio(); const g=ac.createGain(); g.gain.value=.05 * settings.effectsVolume; g.connect(ac.destination); [110, 147, 196, 277].forEach((f,i)=>{ const o=ac.createOscillator(); o.type='sawtooth'; o.frequency.value=f; o.connect(g); o.start(); o.stop(ac.currentTime+0.5+i*0.02)}); }
  function subBoom(){ if(!audioEnabled) return; ensureAudio(); const o=ac.createOscillator(); const g=ac.createGain(); o.type='sine'; o.frequency.setValueAtTime(160, ac.currentTime); o.frequency.exponentialRampToValueAtTime(40, ac.currentTime+0.6); g.gain.value=.06 * settings.effectsVolume; o.connect(g); g.connect(ac.destination); o.start(); o.stop(ac.currentTime+0.65); }

  // Dissonant loop (detuned organ)
  let musicNode; function startMusic(){ if(!audioEnabled) return; if(musicInterval){ clearInterval(musicInterval); musicInterval=null; } if(musicNode){ try{musicNode.stop();}catch{}} const g=ac.createGain(); musicGain = g; g.gain.value=.03 * settings.musicVolume; g.connect(ac.destination); const freqs=[196, 247, 330]; const detunes=[-8, 0, +7]; const oscs=[]; for(let i=0;i<freqs.length;i++){ const o=ac.createOscillator(); o.type='triangle'; o.frequency.value=freqs[i]; o.detune.value=detunes[i]; o.connect(g); o.start(); oscs.push(o);} // slow filter wobble
    musicInterval = setInterval(()=>{ if(!ac || !musicGain) return; musicGain.gain.value = (.02 + Math.random()*0.015) * settings.musicVolume; }, 1200);
    musicNode = { stop(){ oscs.forEach(o=>o.stop()); } };
  }

  function updateMusicGain(){ if(musicGain){ musicGain.gain.value = (.03) * settings.musicVolume; } }

  // Whispers (procedural hiss + formant-ish tone)
  function whisper(){ if(!audioEnabled) return; ensureAudio(); const dur=0.9; const n=ac.createBuffer(1, ac.sampleRate*dur, ac.sampleRate); const d=n.getChannelData(0); for(let i=0;i<d.length;i++){ const t=i/d.length; d[i]=(Math.random()*2-1)*0.4*(1-t); } const s=ac.createBufferSource(); s.buffer=n; const g=ac.createGain(); g.gain.value=.03; s.connect(g); g.connect(ac.destination); s.start(); }

  function syncAudioButton(){ if(muteBtn) muteBtn.textContent = audioEnabled? 'ðŸ”Š Audio':'ðŸ”‡ Muted'; }

  function setAudio(flag, chime=true){
    const next = !!flag;
    audioEnabled = next;
    settings.audioEnabled = next;
    persistSettings();
    syncAudioButton();
    if(!next){
      if(musicNode){ try{ musicNode.stop(); } catch{} musicNode = null; }
      if(musicInterval){ clearInterval(musicInterval); musicInterval=null; }
      if(musicGain){ musicGain.gain.value = 0; }
    }
    if(next){
      ensureAudio();
      updateMusicGain();
      if(chime) tone(720,0.06,'sine',0.03);
    }
  }

  syncAudioButton();

  if(muteBtn){ muteBtn.onclick = () => { setAudio(!audioEnabled); }; }

  // ===== Sprites (embedded SVG -> Image) =====
  const Spr = {};
  function svgToImg(svg){ const img=new Image(); img.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(svg.trim()); return img; }
  // Eyeball ball sprite (normal)
  Spr.ball = svgToImg(`
  <svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'>
    <defs>
      <radialGradient id='g1' cx='50%' cy='50%' r='50%'>
        <stop offset='0%' stop-color='#fff'/>
        <stop offset='100%' stop-color='#ddd'/>
      </radialGradient>
    </defs>
    <circle cx='32' cy='32' r='30' fill='url(#g1)' stroke='#c9c9c9' stroke-width='2'/>
    <circle cx='32' cy='32' r='18' fill='#8b1226'/>
    <circle cx='30' cy='31' r='9' fill='#050508'/>
    <circle cx='28' cy='29' r='3' fill='#9e9eff' opacity='.5'/>
    <path d='M6 20 C14 18, 20 14, 26 12' stroke='#e33' stroke-width='2' fill='none' opacity='.6'/>
    <path d='M8 40 C18 42, 14 50, 22 54' stroke='#e33' stroke-width='2' fill='none' opacity='.6'/>
    <path d='M58 22 C46 16, 40 14, 34 12' stroke='#e33' stroke-width='2' fill='none' opacity='.6'/>
  </svg>`);
  // Astral prism ball
  Spr.astral = svgToImg(`
  <svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'>
    <defs>
      <radialGradient id='astralCore' cx='50%' cy='50%' r='48%'>
        <stop offset='0%' stop-color='#fdf4ff'/>
        <stop offset='60%' stop-color='#c084fc'/>
        <stop offset='100%' stop-color='#5b21b6'/>
      </radialGradient>
      <linearGradient id='astralRing' x1='0' y1='0' x2='1' y2='1'>
        <stop offset='0%' stop-color='#a855f7' stop-opacity='.8'/>
        <stop offset='100%' stop-color='#22d3ee' stop-opacity='.9'/>
      </linearGradient>
    </defs>
    <circle cx='32' cy='32' r='28' fill='url(#astralCore)' stroke='#ede9fe' stroke-width='2'/>
    <g stroke='url(#astralRing)' stroke-width='3' stroke-linecap='round' fill='none' opacity='.85'>
      <path d='M12 30 C24 16, 40 16, 52 30'/>
      <path d='M12 34 C24 48, 40 48, 52 34' opacity='.7'/>
    </g>
    <circle cx='32' cy='32' r='10' fill='#0f172a'/>
    <circle cx='30' cy='30' r='4' fill='#f8fafc' opacity='.7'/>
  </svg>`);
  // Voltaic lash ball
  Spr.voltaic = svgToImg(`
  <svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'>
    <defs>
      <radialGradient id='voltCore' cx='50%' cy='48%' r='52%'>
        <stop offset='0%' stop-color='#eff6ff'/>
        <stop offset='70%' stop-color='#38bdf8'/>
        <stop offset='100%' stop-color='#0f172a'/>
      </radialGradient>
    </defs>
    <circle cx='32' cy='32' r='29' fill='url(#voltCore)' stroke='#0ea5e9' stroke-width='2'/>
    <g stroke='#facc15' stroke-width='2.4' stroke-linecap='round' fill='none' opacity='.9'>
      <path d='M16 18 L24 26 L20 34 L28 40 L24 48'/>
      <path d='M36 16 L44 24 L40 32 L48 38 L42 46' opacity='.7'/>
    </g>
    <circle cx='32' cy='32' r='9' fill='#020617'/>
    <circle cx='30' cy='30' r='3' fill='#f8fafc' opacity='.75'/>
  </svg>`);
  // Graven well ball
  Spr.graven = svgToImg(`
  <svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'>
    <defs>
      <radialGradient id='gravCore' cx='50%' cy='50%' r='52%'>
        <stop offset='0%' stop-color='#fff7ed'/>
        <stop offset='55%' stop-color='#fb923c'/>
        <stop offset='100%' stop-color='#7c2d12'/>
      </radialGradient>
    </defs>
    <circle cx='32' cy='32' r='30' fill='url(#gravCore)' stroke='#fdba74' stroke-width='2'/>
    <circle cx='32' cy='32' r='18' fill='none' stroke='#fb923c' stroke-width='3' stroke-dasharray='8 6' opacity='.8'/>
    <circle cx='32' cy='32' r='9' fill='#1b0f05'/>
    <circle cx='30' cy='30' r='3' fill='#fde68a' opacity='.7'/>
  </svg>`);
  // Cursed face peg (two frames: open/closed mouth)
  Spr.cursedA = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'><defs><radialGradient id='r' cx='50%' cy='40%' r='60%'><stop offset='0%' stop-color='#ff647c'/><stop offset='60%' stop-color='#d2122e'/><stop offset='100%' stop-color='#6b0814'/></radialGradient></defs><circle cx='24' cy='24' r='22' fill='url(#r)' stroke='#2b0007' stroke-width='2'/><ellipse cx='16' cy='20' rx='6' ry='5' fill='#1a0010'/><ellipse cx='32' cy='20' rx='6' ry='5' fill='#1a0010'/><path d='M12 30 Q24 38 36 30' stroke='#1a0010' stroke-width='4' fill='none'/></svg>`);
  Spr.cursedB = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'><defs><radialGradient id='r' cx='50%' cy='40%' r='60%'><stop offset='0%' stop-color='#ff647c'/><stop offset='60%' stop-color='#d2122e'/><stop offset='100%' stop-color='#6b0814'/></radialGradient></defs><circle cx='24' cy='24' r='22' fill='url(#r)' stroke='#2b0007' stroke-width='2'/><ellipse cx='16' cy='20' rx='6' ry='5' fill='#1a0010'/><ellipse cx='32' cy='20' rx='6' ry='5' fill='#1a0010'/><path d='M12 30 Q24 28 36 30' stroke='#1a0010' stroke-width='5' fill='none'/></svg>`);
  // Normal meat peg
  Spr.meat = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='44' height='44' viewBox='0 0 44 44'><defs><radialGradient id='m' cx='50%' cy='45%' r='65%'><stop offset='0%' stop-color='#ffb3c2'/><stop offset='70%' stop-color='#a11428'/><stop offset='100%' stop-color='#47020a'/></radialGradient></defs><circle cx='22' cy='22' r='20' fill='url(#m)' stroke='#36010a' stroke-width='2'/><path d='M8 18 Q22 12 36 18' stroke='#5b0210' stroke-width='2' fill='none' opacity='.6'/></svg>`);
  // Steel peg
  Spr.steel = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='44' height='44' viewBox='0 0 44 44'><defs><radialGradient id='s' cx='35%' cy='35%' r='70%'><stop offset='0%' stop-color='#fafafa'/><stop offset='70%' stop-color='#8f949c'/><stop offset='100%' stop-color='#3c4046'/></radialGradient></defs><circle cx='22' cy='22' r='19' fill='url(#s)' stroke='#24262a' stroke-width='2'/><circle cx='22' cy='22' r='5' fill='#1a1c1f'/></svg>`);
  // Blood splat sprite
  Spr.splat = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'><g fill='#6f0011'><path d='M32 10c-8 0-13 6-13 11s4 9 13 9 16-4 16-9-8-11-16-11z'/><circle cx='12' cy='20' r='5'/><circle cx='20' cy='44' r='6'/><circle cx='48' cy='36' r='7'/><circle cx='40' cy='54' r='4'/></g></svg>`);
  // Background wallpaper
  Spr.bg = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='960' height='640' viewBox='0 0 960 640'>
    <defs>
      <linearGradient id='bgFloor' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#18191f'/>
        <stop offset='60%' stop-color='#0f1016'/>
        <stop offset='100%' stop-color='#06070a'/>
      </linearGradient>
      <radialGradient id='spot' cx='50%' cy='0%' r='80%'>
        <stop offset='0%' stop-color='rgba(239,68,68,.42)'/>
        <stop offset='35%' stop-color='rgba(190,24,24,.2)'/>
        <stop offset='100%' stop-color='rgba(0,0,0,0)'/>
      </radialGradient>
      <linearGradient id='bandA' x1='0' y1='0' x2='1' y2='0'>
        <stop offset='0%' stop-color='rgba(239,68,68,.8)'/>
        <stop offset='100%' stop-color='rgba(239,68,68,0)'/>
      </linearGradient>
      <linearGradient id='bandB' x1='1' y1='0' x2='0' y2='0'>
        <stop offset='0%' stop-color='rgba(127,29,29,.8)'/>
        <stop offset='100%' stop-color='rgba(127,29,29,0)'/>
      </linearGradient>
    </defs>
    <rect width='960' height='640' fill='url(#bgFloor)'/>
    <rect width='960' height='320' fill='url(#spot)'/>
    <g opacity='.22'>
      <path d='M-60 520 C160 440, 320 560, 540 520 S 940 560, 1020 500' stroke='rgba(239,68,68,.42)' stroke-width='90' fill='none' stroke-linecap='round'/>
      <path d='M-40 440 C140 500, 360 420, 620 460 S 940 420, 1080 460' stroke='rgba(82,82,94,.4)' stroke-width='36' fill='none' stroke-linecap='round' stroke-dasharray='46 26'/>
    </g>
    <g opacity='.28'>
      <rect x='0' y='0' width='160' height='640' fill='url(#bandA)'/>
      <rect x='800' y='0' width='160' height='640' fill='url(#bandB)'/>
    </g>
  </svg>`);
  // Bucket monster (open/closed)
  Spr.bucketOpen = svgToImg(`
  <svg xmlns='http://www.w3.org/2000/svg' width='150' height='62' viewBox='0 0 150 62'>
    <defs>
      <radialGradient id='trapPit' cx='50%' cy='70%' r='78%'>
        <stop offset='0%' stop-color='#1a0307'/>
        <stop offset='65%' stop-color='#050103'/>
        <stop offset='100%' stop-color='rgba(0,0,0,0)'/>
      </radialGradient>
      <linearGradient id='trapSkinOpen' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#66131f'/>
        <stop offset='100%' stop-color='#0a0204'/>
      </linearGradient>
      <linearGradient id='trapTongue' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#f97316'/>
        <stop offset='100%' stop-color='#7c2d12'/>
      </linearGradient>
    </defs>
    <ellipse cx='75' cy='54' rx='72' ry='22' fill='url(#trapPit)' opacity='.85'/>
    <path d='M10 18 C26 2, 124 2, 140 18 C146 46, 122 60, 75 60 C28 60, 4 46, 10 18 Z' fill='url(#trapSkinOpen)' stroke='#f43f5e' stroke-width='3.2'/>
    <path d='M18 30 C34 10, 116 10, 132 30' stroke='#fb7185' stroke-width='4' stroke-linecap='round' fill='none'/>
    <path d='M24 36 C46 52, 104 52, 126 36' stroke='#b91c1c' stroke-width='8' stroke-linecap='round' fill='none'/>
    <path d='M64 34 C78 32, 90 34, 90 42 C90 48, 80 54, 70 52 C58 50, 60 40, 64 34 Z' fill='url(#trapTongue)' stroke='#7c2d12' stroke-width='2'/>
    <g stroke='#1f0a0f' stroke-width='3' fill='#fef2f2'>
      <path d='M22 26 L32 6 L42 26 Z'/>
      <path d='M48 28 L58 4 L68 28 Z'/>
      <path d='M82 28 L92 4 L102 28 Z'/>
      <path d='M108 26 L118 6 L128 26 Z'/>
    </g>
    <g stroke='#1f0a0f' stroke-width='2.6' fill='#fef2f2'>
      <path d='M34 44 L42 58 L50 44 Z'/>
      <path d='M60 46 L68 60 L76 46 Z'/>
      <path d='M88 46 L96 60 L104 46 Z'/>
      <path d='M114 44 L122 58 L130 44 Z'/>
    </g>
    <path d='M48 44 Q76 56 104 44' stroke='#fde68a' stroke-width='3' stroke-linecap='round' opacity='.65'/>
    <path d='M58 30 C70 20, 80 20, 92 30' stroke='rgba(250,204,21,.4)' stroke-width='3' stroke-linecap='round' fill='none'/>
    <circle cx='52' cy='20' r='9' fill='#f9fafb' stroke='#0f172a' stroke-width='2'/>
    <circle cx='98' cy='20' r='9' fill='#f9fafb' stroke='#0f172a' stroke-width='2'/>
    <circle cx='50' cy='20' r='3.5' fill='#0a0f1f'/>
    <circle cx='96' cy='20' r='3.5' fill='#0a0f1f'/>
    <path d='M46 50 Q52 60 64 56' stroke='#fb7185' stroke-width='2' fill='none' opacity='.7'/>
    <path d='M84 56 Q96 60 102 50' stroke='#fb7185' stroke-width='2' fill='none' opacity='.7'/>
  </svg>`);
  Spr.bucketClosed = svgToImg(`
  <svg xmlns='http://www.w3.org/2000/svg' width='150' height='62' viewBox='0 0 150 62'>
    <defs>
      <linearGradient id='trapSkinClosed' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#330a11'/>
        <stop offset='100%' stop-color='#050104'/>
      </linearGradient>
    </defs>
    <path d='M14 22 C24 4, 126 4, 136 22 C130 46, 112 56, 75 58 C38 56, 20 46, 14 22 Z' fill='url(#trapSkinClosed)' stroke='#7f1d1d' stroke-width='3'/>
    <path d='M24 24 C42 18, 108 18, 126 24' stroke='#f87171' stroke-width='4' stroke-linecap='round' fill='none'/>
    <path d='M34 34 C52 40, 98 40, 116 34' stroke='#fde68a' stroke-width='3' stroke-linecap='round' opacity='.6'/>
    <g stroke='#1f0a0f' stroke-width='2.6' fill='#fef2f2'>
      <path d='M32 30 L40 16 L48 30 Z'/>
      <path d='M58 30 L66 14 L74 30 Z'/>
      <path d='M86 30 L94 14 L102 30 Z'/>
      <path d='M112 30 L120 16 L128 30 Z'/>
    </g>
    <circle cx='58' cy='22' r='6.5' fill='#fdf6ec' stroke='#1f0a0f' stroke-width='2'/>
    <circle cx='92' cy='22' r='6.5' fill='#fdf6ec' stroke='#1f0a0f' stroke-width='2'/>
    <circle cx='56' cy='22' r='2.6' fill='#111827'/>
    <circle cx='90' cy='22' r='2.6' fill='#111827'/>
  </svg>`);

  // ===== Game State =====
  const svgData = (svg) => 'data:image/svg+xml;utf8,' + encodeURIComponent(svg.trim());
  const DEVICE_SVGS = {
    phone: `<svg xmlns='http://www.w3.org/2000/svg' width='128' height='240' viewBox='0 0 128 240'>
      <defs>
        <linearGradient id='phBody' x1='0' y1='0' x2='0' y2='1'>
          <stop offset='0%' stop-color='#161b2a'/>
          <stop offset='60%' stop-color='#0f121d'/>
          <stop offset='100%' stop-color='#080a12'/>
        </linearGradient>
        <linearGradient id='phEdge' x1='0' y1='0' x2='1' y2='1'>
          <stop offset='0%' stop-color='#f87171'/>
          <stop offset='100%' stop-color='#ef4444'/>
        </linearGradient>
      </defs>
      <rect x='12' y='8' width='104' height='224' rx='22' fill='url(#phBody)' stroke='url(#phEdge)' stroke-width='4'/>
      <rect x='26' y='34' width='76' height='160' rx='14' fill='#1d2335' stroke='#111726' stroke-width='2'/>
      <rect x='48' y='22' width='32' height='6' rx='3' fill='#f8fafc' opacity='.6'/>
      <circle cx='64' cy='212' r='10' fill='#101622' stroke='#f87171' stroke-width='2'/>
      <circle cx='64' cy='212' r='4' fill='#111827'/>
    </svg>`,
    laptop: `<svg xmlns='http://www.w3.org/2000/svg' width='280' height='180' viewBox='0 0 280 180'>
      <rect x='30' y='20' width='220' height='120' rx='12' fill='#111827' stroke='#38bdf8' stroke-width='4'/>
      <rect x='46' y='36' width='188' height='90' rx='6' fill='#1e293b'/>
      <path d='M10 150h260l-18 28H28z' fill='#0f172a' stroke='#38bdf8' stroke-width='3'/>
    </svg>`,
    tablet: `<svg xmlns='http://www.w3.org/2000/svg' width='220' height='260' viewBox='0 0 220 260'>
      <rect x='20' y='20' width='180' height='220' rx='20' fill='#0f1628' stroke='#f97316' stroke-width='4'/>
      <rect x='36' y='44' width='148' height='172' rx='14' fill='#1a2238'/>
      <circle cx='110' cy='218' r='8' fill='#f97316'/>
    </svg>`
  };
  const DEVICE_OPTIONS = [
    { id:'phone', label:'Phone', note:'Rotate to landscape before you shoot.', img: svgData(DEVICE_SVGS.phone) },
    { id:'tablet', label:'Tablet', note:'Wider touch lanes and balanced spacing.', img: svgData(DEVICE_SVGS.tablet) },
    { id:'laptop', label:'Laptop / Desktop', note:'Full keyboard shortcuts and crisp pixels.', img: svgData(DEVICE_SVGS.laptop) }
  ];
  const STATE = { BOOT:0, MENU:1, PLAY:2, GAMEOVER:3, PAUSE:4 };
  let state = STATE.BOOT;
  let bootProg=0;
  let bootMsgIdx=0;
  let bootTipIdx=0;
  let bootStart=0;
  let bootSkip=false;
  let lastBootTipChange=0;
  let lastBootMsgChange=0;
  let settingsOpen = false;
  let stateBeforePause = STATE.PLAY;
  let tutorialShown = false;
  let jumpscareCooldown = 0;
  let jumpscareActive = false;
  let orientationBlockState = null;
  function syncHUDVisibility(){ if(!hudLayer) return; hudLayer.style.opacity = state===STATE.PLAY?1:0; }
  syncHUDVisibility();
  const BOOT_MIN_MS = 9000;
  const bootMsgs = [
    "Sound-checking the voidâ€¦",
    "Tuning haunted stringsâ€¦",
    "Feeding amps with bloodâ€¦",
    "Rehearsing the screamsâ€¦",
    "Dropping the crimson curtainâ€¦"
  ];
  const bootTips = [
    'Tip: Cursed reds fuel the fear meter. Clear them early to avoid panic mode later.',
    'Reminder: Catching the bucket refunds a ball and pumps your streak. Don\'t snub that bucket beast.',
    'Did you know? Steel pegs only bounceâ€”bring power-ups or angle tricks to slip past.',
    'Backstage gossip: Astral Prism lets you ghost through walls of pegs â€” save it for late fights.',
    'Joke: Why did the eyeball join the band? It had perfect pitch and zero stage fright.',
    'Trick: Bank shots off the arena walls to reach tucked-away reds without wasting height.',
    'Lore: Fear whispers get louder after 60%. Maybe listenâ€¦ or maybe aim faster.',
    'Pro move: Voltaic Lash loves big clusters â€” hit something central to arc across the field.'
  ];
  const MENU_HINTS = [
    "Catch the bucket beast to earn another shot.",
    "Steel pegs just bounce â€” bring powers to break the rhythm.",
    "Fear climbs faster with streaks. High fear changes everything.",
    "Astral Prism phases through tight clusters; Voltaic Lash stuns nearby pegs.",
    "Press ESC anytime for settings, blood toggle, or a reset."
  ];
  const TUTORIAL_STEPS = [
    { title: 'Aim & Fire', body: 'Move the mouse to aim from the top center. Left click to launch the haunted eyeball.' },
    { title: 'Clear The Reds', body: 'Break every cursed red peg before you run out of shots to open the gate to the next stage.' },
    { title: 'Catch The Bucket', body: 'Drop into the bucket beast to recover a ball and boost your streak.' },
    { title: 'Fear Meter', body: 'Streaks and cursed hits fill the Fear bar. High fear twists the arena and unlocks stronger effects.' }
  ];

  function renderScoreList(){
    let html = '<div class="score-list">';
    for(let i=1;i<=TOTAL_LEVELS;i++){
      html += `<div class="score-item"><span>Level ${i}</span><span>${formatScore(getBestScore(i))}</span></div>`;
    }
    html += '</div>';
    return html;
  }

  const world = {
    baseGravity: 0.34,
    gravity: 0.34,
    friction: 0.995,
    ballsLeft: 10,
    score: 0,
    streak: 0,
    level: 1,
    ball: null,
    ballType: POW.NONE,
    pierce: 0,
    chainCharges: 0,
    gravenReady: false,
    pegs: [],
    hallucinations: [],
    decals: [],
    particles: [],
    bucket: { x: W*0.25, y: H-60, w: 150, h: 52, vx: 2.2, open: true, anim:0 },
    aim: { x: W/2, y: 60, ang: -Math.PI/2, power: 14, ready: false },
    clearedCursed: 0,
    totalCursed: 0,
    screenShake: 0,
    fear: 0,
    levelBaselineScore: 0,
  };

  // ===== Level helpers =====
  function makeGrid(rows, cols, offsetY=140, jitter=10, curseEvery=5){
    const arr=[]; const gapX=W/(cols+1), gapY=52;
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
      const x = gapX*(c+1) + (Math.random()*2-1)*jitter + (r%2?gapX/2:0);
      const y = offsetY + r*gapY + (Math.random()*2-1)*jitter;
      const cursed = ((r*cols+c)%curseEvery===0);
      arr.push({x,y,r:20,type: cursed? 'cursed':'normal', hit:false, t:Math.random()*100});
    }
    return arr;
  }
  function ring(cx,cy,rad,count,type='normal'){ const arr=[]; for(let i=0;i<count;i++){ const a=i/count*Math.PI*2; arr.push({x:cx+Math.cos(a)*rad,y:cy+Math.sin(a)*rad,r:20,type,hit:false,t:Math.random()*100}); } return arr; }
  function spiral(cx, cy, turns=10, step=22, count=90){ const arr=[]; let t=0; for(let i=0;i<count;i++){ const r= t*step; const a = t * 0.55; arr.push({x:cx+Math.cos(a)*r, y:cy+Math.sin(a)*r, r:18, type: (i%7===0? 'cursed':'normal'), hit:false,t:Math.random()*100}); t += turns/count; } return arr; }
  function mix(arr, nSteel=10){ for(let i=0;i<nSteel && i<arr.length;i++) arr[i].type='steel'; return arr; }
  const peg = (x,y,type='normal',r=20)=>({x,y,r,type,hit:false,t:Math.random()*100});
  function columnsLayout(colCount=6,rowCount=6,offsetY=130,shift=20,curseStride=3){
    const arr=[]; const gapX=W/(colCount+1); const gapY=52;
    for(let c=0;c<colCount;c++){
      for(let r=0;r<rowCount;r++){
        const x = gapX*(c+1);
        const y = offsetY + r*gapY + (c%2?shift:-shift);
        const cursed = ((r + c)%curseStride===0);
        arr.push(peg(x,y,cursed?'cursed':'normal'));
      }
    }
    return arr;
  }
  function waveLayout(rows=5, cols=10, offsetY=120, amplitude=36, freq=0.6){
    const arr=[]; const gapX=W/(cols+1); const gapY=52;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = gapX*(c+1);
        const baseY = offsetY + r*gapY;
        const y = baseY + Math.sin((c+ r*0.4)*freq)*amplitude;
        const cursed = ((c+r)%4===0);
        arr.push(peg(x,y,cursed?'cursed':'normal'));
      }
    }
    return arr;
  }
  function targetLayout(cx, cy){
    return [
      ...ring(cx, cy, 60, 8),
      ...ring(cx, cy, 100, 12, 'cursed'),
      ...ring(cx, cy, 140, 16),
      ...ring(cx, cy, 180, 20, 'cursed')
    ];
  }
  function scatterLayout(count=48, cursedRatio=0.26, top=120, bottom=H-140){
    const arr=[];
    for(let i=0;i<count;i++){
      const type = (Math.random()<cursedRatio)? 'cursed':'normal';
      const x = 70 + Math.random()*(W-140);
      const y = top + Math.random()*(bottom-top);
      arr.push(peg(x,y,type));
    }
    return arr;
  }
  function doubleSpiral(){
    const a = spiral(W*0.25, H*0.45, 10, 14, 70).map(p=>({ ...p, type: (Math.random()<0.25)?'cursed':p.type }));
    const b = spiral(W*0.75, H*0.45, 10, 14, 70).map(p=>({ ...p, type: (Math.random()<0.25)?'cursed':p.type }));
    return a.concat(b);
  }

  // Level blueprints maintain a gentle difficulty ramp with varied geometry.
  function tutorialGarden(){
    const arr=[];
    const cols = 5;
    const gap = W/(cols+1);
    const rows = [240, 310];
    rows.forEach((y,rowIdx)=>{
      for(let c=0;c<cols;c++){
        const x = gap*(c+1);
        const center = c===Math.floor(cols/2);
        const cursed = rowIdx===0 ? (center || c===1 || c===3) : (rowIdx===1 && c%2===1);
        arr.push(peg(x, y, cursed? 'cursed':'normal'));
      }
    });
    arr.push(peg(W/2, 380, 'cursed'));
    arr.push(peg(W/2-110, 430, 'normal'));
    arr.push(peg(W/2+110, 430, 'normal'));
    return arr;
  }

  function emberOrbit(){
    const arr=[];
    arr.push(...ring(W/2, 320, 90, 6, 'cursed'));
    const orbit = ring(W/2, 320, 150, 10);
    orbit.forEach((p,i)=>{ if(i%3===0) p.type='cursed'; });
    arr.push(...orbit);
    arr.push(peg(W/2, 220, 'normal'));
    arr.push(peg(W/2, 420, 'cursed'));
    arr.push(peg(160, 260, 'normal'));
    arr.push(peg(W-160, 260, 'normal'));
    arr.push(peg(160, 400, 'cursed'));
    arr.push(peg(W-160, 400, 'cursed'));
    return arr;
  }

  function staggeredVeil(){
    const arr=[];
    const cols = 5;
    const gap = W/(cols+1);
    for(let r=0;r<4;r++){
      const y = 220 + r*60;
      for(let c=0;c<cols;c++){
        const x = gap*(c+1) + (r%2? gap/2 : 0);
        const cursed = (r<=1 && (c===1 || c===3)) || (r>=2 && c%2===0);
        arr.push(peg(x, y, cursed? 'cursed':'normal'));
      }
    }
    arr.push(peg(W/2, 460, 'cursed'));
    arr.push(peg(W/2-150, 500, 'normal'));
    arr.push(peg(W/2+150, 500, 'normal'));
    return arr;
  }

  function tidalSteps(){
    const arr = waveLayout(4, 8, 220, 40, 0.55);
    arr.forEach((p,i)=>{ if(i%5===0) p.type='cursed'; });
    const rim = ring(W/2, 520, 130, 10);
    rim.forEach((p,i)=>{ if(i%2===0) p.type='cursed'; });
    arr.push(...rim);
    return arr;
  }

  function cagedCross(){
    const arr=[];
    [260, 320, 380].forEach(y => arr.push(peg(W/2, y, 'cursed')));
    arr.push(peg(W/2-100, 320, 'cursed'));
    arr.push(peg(W/2+100, 320, 'cursed'));
    const guard = ring(W/2, 320, 180, 12);
    guard.forEach((p,i)=>{ if(i%3===0) p.type='cursed'; });
    arr.push(...guard);
    arr.push(peg(160, 240, 'normal'));
    arr.push(peg(W-160, 240, 'normal'));
    arr.push(peg(160, 400, 'normal'));
    arr.push(peg(W-160, 400, 'normal'));
    return arr;
  }

  function cinderColumns(){
    const arr = columnsLayout(5, 5, 200, 24, 4);
    arr.forEach((p,i)=>{ if(i%7===0) p.type='cursed'; });
    arr.push(peg(140, 500, 'steel'));
    arr.push(peg(W-140, 500, 'steel'));
    arr.push(peg(W/2, 470, 'cursed'));
    return arr;
  }

  function bucketBallet(){
    const arr=[];
    const inner = ring(W/2, 300, 110, 8, 'cursed');
    const outer = ring(W/2, 300, 180, 12);
    outer.forEach((p,i)=>{ if(i%3===0) p.type='cursed'; });
    arr.push(...inner, ...outer);
    arr.push(peg(W/2, 500, 'cursed'));
    arr.push(peg(W/2-150, 460, 'normal'));
    arr.push(peg(W/2+150, 460, 'normal'));
    arr.push(peg(200, 380, 'steel'));
    arr.push(peg(W-200, 380, 'steel'));
    return arr;
  }

  function twinSigils(){
    const arr=[];
    const left = ring(W/2 - 160, 320, 110, 6);
    left.forEach((p,i)=>{ if(i%2===0) p.type='cursed'; });
    const right = ring(W/2 + 160, 320, 110, 6);
    right.forEach((p,i)=>{ if(i%2===1) p.type='cursed'; });
    arr.push(...left, ...right);
    const base = ring(W/2, 520, 150, 12);
    base.forEach((p,i)=>{ if(i%3===0) p.type='cursed'; });
    arr.push(...base);
    arr.push(peg(W/2, 320, 'cursed'));
    arr.push(peg(W/2, 220, 'steel'));
    arr.push(peg(W/2, 420, 'steel'));
    return arr;
  }

  function whisperSpiral(){
    const arr = spiral(W/2, H*0.48, 11, 22, 82);
    arr.forEach((p,i)=>{
      if(i%6===0) p.type='cursed';
      if(i%15===0) p.type='steel';
    });
    const basin = ring(W/2, H*0.72, 150, 12);
    basin.forEach((p,i)=>{ if(i%3===0) p.type='cursed'; });
    arr.push(...basin);
    return arr;
  }

  function lanternLattice(){
    const arr = makeGrid(4, 9, 200, 0, 4);
    arr.forEach((p,i)=>{ if(i%8===0) p.type='cursed'; });
    const rails = ring(W/2, 540, 150, 12);
    rails.forEach((p,i)=>{ if(i%3===0) p.type='cursed'; });
    arr.push(...rails);
    arr.push(peg(160, 420, 'steel'));
    arr.push(peg(W-160, 420, 'steel'));
    return arr;
  }

  function voidBridges(){
    const arr=[];
    for(let i=0;i<6;i++){
      const x = 150 + i*130;
      arr.push(peg(x, 240, i%2===0?'cursed':'normal'));
      arr.push(peg(x, 320, i%3===0?'steel':'normal'));
      arr.push(peg(x, 400, i%2===1?'cursed':'normal'));
    }
    const guard = ring(W/2, 360, 200, 16);
    guard.forEach((p,i)=>{
      if(i%4===0) p.type='steel';
      else if(i%2===0) p.type='cursed';
    });
    arr.push(...guard);
    const floor = ring(W/2, 560, 150, 12);
    floor.forEach((p,i)=>{ if(i%3===0) p.type='cursed'; });
    arr.push(...floor);
    return arr;
  }

  function emberBloom(){
    const arr=[];
    const cy = 340;
    arr.push(...ring(W/2, cy, 80, 6, 'cursed'));
    const mid = ring(W/2, cy, 140, 10);
    mid.forEach((p,i)=>{ if(i%2===0) p.type='cursed'; });
    const outer = ring(W/2, cy, 210, 14);
    outer.forEach((p,i)=>{ if(i%4===0) p.type='steel'; });
    arr.push(...mid, ...outer);
    for(let i=0;i<6;i++){
      const a = -Math.PI/2 + i*(Math.PI*2/6);
      arr.push(peg(W/2 + Math.cos(a)*250, cy + Math.sin(a)*120, i%2===0?'steel':'normal'));
    }
    arr.push(...ring(W/2, 560, 150, 12));
    return arr;
  }

  function glassGarden(){
    const arr = waveLayout(4, 8, 220, 38, 0.5);
    arr.forEach((p,i)=>{ if(i%4===0) p.type='cursed'; });
    for(let i=0;i<5;i++){
      const x = 180 + i*160;
      arr.push(peg(x, 260, i%2===0?'cursed':'normal'));
      arr.push(peg(x, 420, i%3===0?'steel':'normal'));
    }
    const petals = ring(W/2, 560, 150, 12);
    petals.forEach((p,i)=>{ if(i%4===0) p.type='cursed'; });
    arr.push(...petals);
    return arr;
  }

  function obsidianCrown(){
    const arr = [...targetLayout(W/2, 280)];
    arr.push(...ring(W/2, 280, 220, 16, 'cursed'));
    for(let i=0;i<6;i++){
      arr.push(peg(160 + i*120, 520, i%2===0?'steel':'cursed'));
    }
    arr.push(peg(W/2, 520, 'cursed'));
    return arr;
  }

  function leviathanRise(){
    const arr=[];
    for(let r=0;r<6;r++){
      const count = 4 + Math.min(r, 3);
      const spacing = 80;
      const startX = W/2 - spacing*(count-1)/2;
      const y = 220 + r*55;
      for(let c=0;c<count;c++){
        const x = startX + c*spacing;
        const edge = (c===0 || c===count-1);
        const cursed = edge || (r%2===0 && c%2===0);
        arr.push(peg(x, y, cursed? 'cursed':'normal'));
      }
    }
    const moat = ring(W/2, 560, 150, 12);
    moat.forEach((p,i)=>{
      if(i%3===0) p.type='steel';
      else if(i%2===0) p.type='cursed';
    });
    arr.push(...moat);
    return arr;
  }

  function voidChorus(){
    const arr=[];
    for(let i=0;i<8;i++){
      const x = 140 + i*100;
      arr.push(peg(x, 200 + Math.sin(i*0.4)*50, i%3===0?'cursed':'normal'));
      arr.push(peg(x, 360 + Math.cos(i*0.5)*40, i%4===0?'steel':'normal'));
      arr.push(peg(x, 520 + Math.sin(i*0.6)*30, i%2===0?'cursed':'normal'));
    }
    arr.push(...ring(W/2, 360, 200, 18, 'cursed'));
    return arr;
  }

  function labyrinthCage(){
    const arr=[];
    const rows=5, cols=9;
    const gapX=W/(cols+1); const gapY=70;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = gapX*(c+1);
        const y = 200 + r*gapY;
        const border = (r===0||r===rows-1||c===0||c===cols-1);
        const cursed = border ? (r+c)%2===0 : (r+c)%3===0;
        arr.push(peg(x,y, cursed? 'cursed':'normal'));
      }
    }
    for(let i=0;i<6;i++){
      arr.push(peg(140 + i*120, 340 + Math.sin(i)*50, i%2===0?'steel':'normal'));
    }
    arr.push(...ring(W/2, 560, 150, 12));
    return arr;
  }

  function impactField(){
    const arr = scatterLayout(34, 0.3, 200, H-220);
    for(let i=0;i<5;i++){
      const x = 180 + i*140;
      arr.push(peg(x, 240, i%2===0?'cursed':'normal'));
      arr.push(peg(x, 500, i%3===0?'steel':'cursed'));
    }
    const core = ring(W/2, 360, 120, 10, 'cursed');
    core.forEach((p,i)=>{ if(i%3===0) p.type='steel'; });
    arr.push(...core);
    return arr;
  }

  function eclipseRun(){
    const arr=[];
    arr.push(...waveLayout(5, 10, 210, 52, 0.8));
    arr.push(...ring(W/2, 280, 80, 6, 'cursed'));
    const halo = ring(W/2, 280, 200, 14);
    halo.forEach((p,i)=>{ if(i%4===0) p.type='cursed'; });
    arr.push(...halo);
    for(let i=0;i<6;i++){
      arr.push(peg(160 + i*120, 520 + Math.cos(i*0.6)*36, i%2===0?'steel':'normal'));
    }
    return arr;
  }

  function finaleCataclysm(){
    const arr=[];
    arr.push(...ring(W/2, 320, 90, 8, 'cursed'));
    const mid = ring(W/2, 320, 160, 14);
    mid.forEach((p,i)=>{
      if(i%4===0) p.type='cursed';
      if(i%6===0) p.type='steel';
    });
    arr.push(...mid);
    const outer = ring(W/2, 320, 230, 18);
    outer.forEach((p,i)=>{ if(i%3===0) p.type='steel'; });
    arr.push(...outer);
    const spokes = 8;
    for(let i=0;i<spokes;i++){
      const a = i/spokes*Math.PI*2;
      for(let k=1;k<=4;k++){
        const radius = 60 + k*60;
        const type = k===4 ? 'steel' : (k%2===0? 'cursed':'normal');
        arr.push(peg(W/2 + Math.cos(a)*radius, 320 + Math.sin(a)*radius, type));
      }
    }
    for(let i=0;i<6;i++){
      arr.push(peg(160 + i*120, 540 + Math.sin(i*0.6)*50, i%2===0?'cursed':'steel'));
    }
    arr.push(...scatterLayout(22, 0.4, 160, H-200));
    return arr;
  }

  function serializePegs(pegs){
    return pegs.map(p=>({
      x:Math.round(p.x*100)/100,
      y:Math.round(p.y*100)/100,
      r:Math.round((p.r||20)*100)/100,
      type:p.type||'normal'
    }));
  }

  function deserializePegs(data){
    if(!Array.isArray(data)) return [];
    const arr=[];
    for(const entry of data){
      const x = Number(entry?.x);
      const y = Number(entry?.y);
      if(!Number.isFinite(x) || !Number.isFinite(y)) continue;
      const r = Number(entry?.r);
      const type = typeof entry?.type === 'string'? entry.type : 'normal';
      arr.push(peg(x, y, type, Number.isFinite(r)? r : 20));
    }
    return arr;
  }

  const LEVELS = [
    tutorialGarden,
    emberOrbit,
    staggeredVeil,
    tidalSteps,
    cagedCross,
    cinderColumns,
    bucketBallet,
    twinSigils,
    whisperSpiral,
    lanternLattice,
    voidBridges,
    emberBloom,
    glassGarden,
    obsidianCrown,
    leviathanRise,
    voidChorus,
    labyrinthCage,
    impactField,
    eclipseRun,
    finaleCataclysm,
  ];
  const TOTAL_LEVELS = LEVELS.length;

  function loadLevel(i){
    const idx = Math.min(Math.max(1, i), TOTAL_LEVELS) - 1;
    world.level = i;
    world.pegs = LEVELS[idx]();
    world.totalCursed = world.pegs.filter(p=>p.type==='cursed').length;
    world.score = 0;
    world.clearedCursed = 0; world.ball=null; world.aim.ready=true; world.ballsLeft = Math.max(6, 12 - i);
    world.streak=0; lastStreakPing=0; world.fear = 0; world.ballType=POW.NONE; world.pierce=0; world.chainCharges=0; world.gravenReady=false; world.gravity = world.baseGravity; world.hallucinations=[];
    wipeScene();
    world.levelBaselineScore = 0;
    if(i===1 && settings.showTutorial && !tutorialShown){ scheduleTutorial(); }
    sting(); updateHUD();
  }

  function loadCustomLayout(pegs){
    const layout = Array.isArray(pegs)? pegs : [];
    world.level = 1;
    world.pegs = deserializePegs(layout);
    world.totalCursed = world.pegs.filter(p=>p.type==='cursed').length;
    world.score = 0;
    world.clearedCursed = 0;
    world.ball=null;
    world.aim.ready=true;
    world.ballsLeft = 10;
    world.streak=0;
    lastStreakPing=0;
    world.fear = 0;
    world.ballType=POW.NONE;
    world.pierce=0;
    world.chainCharges=0;
    world.gravenReady=false;
    world.gravity = world.baseGravity;
    world.hallucinations=[];
    wipeScene();
    world.levelBaselineScore = 0;
    if(world.pegs.length===0){
      const fallback = makeGrid(3,7,220,10,5);
      world.pegs.push(...fallback);
      world.totalCursed = world.pegs.filter(p=>p.type==='cursed').length;
    }
    sting();
    updateHUD();
  }

  function scheduleTutorial(){
    if(tutorialShown || !settings.showTutorial) return;
    tutorialShown = true;
    world.aim.ready = false;
    setTimeout(()=> showTutorialOverlay(), 400);
  }

  function showTutorialOverlay(){
    if(!settings.showTutorial) return;
    stateBeforePause = STATE.PLAY;
    state = STATE.PAUSE;
    world.aim.ready = false;
    const name = escHTML(settings.playerName || 'Wanderer');
    setOverlay(`<div class="menu tutorial"><div class="title">Setlist Primer</div><p>Welcome, ${name}. Three rules keep the encore alive.</p><p>1. Aim the haunted orb with your mouse and click to release.<br>2. Smash every <b>cursed red peg</b> before you run out of shots.<br>3. Catch the bucket beast to reclaim an eyeball.</p><div class="row" style="gap:12px"><button class="btn" id="tutorialSkip">âœ– Skip Tutorial</button><button class="btn good" id="tutorialBegin">âœ” Begin</button></div></div>`);
    document.getElementById('tutorialSkip').onclick = () => {
      settings.showTutorial = false;
      persistSettings();
      setOverlay('');
      state = STATE.PLAY;
      world.aim.ready = true;
      syncHUDVisibility();
    };
    document.getElementById('tutorialBegin').onclick = () => {
      runTutorialHints(()=>{
        state = STATE.PLAY;
        world.aim.ready = true;
        syncHUDVisibility();
      });
    };
  }

  function runTutorialHints(onDone){
    let idx = 0;
    const advance = () => {
      if(idx >= TUTORIAL_STEPS.length){
        setOverlay('');
        if(onDone) onDone();
        return;
      }
      const step = TUTORIAL_STEPS[idx];
      setOverlay(`<div class="menu hint"><div class="title">${step.title}</div><p>${escHTML(step.body)}</p><button class="btn good" id="hintNext">Continue</button></div>`);
      document.getElementById('hintNext').onclick = () => { idx++; advance(); };
    };
    advance();
  }

  // ===== Entities =====
  class Ball{
    constructor(x,y,vx,vy){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.r=14; this.dead=false; }
    step(){
      this.vy += world.gravity;
      this.vx *= world.friction;
      this.vy *= world.friction;
      this.x += this.vx;
      this.y += this.vy;
      if(this.x < this.r){ this.x=this.r; this.vx*=-1; }
      if(this.x > W-this.r){ this.x=W-this.r; this.vx*=-1; }
      if(this.y < this.r){ this.y=this.r; this.vy*=-1; }
      if(this.y > H-this.r){ this.y = H-this.r; this.vy *= -0.45; this.vx *= 0.96; if(Math.abs(this.vy)<3.5) this.dead=true; }
      this.collidePegs();
      this.collideBucket();
    }
    collidePegs(){
      for(const p of world.pegs){
        if(p.hit) continue;
        const dx=this.x-p.x, dy=this.y-p.y;
        const d=Math.hypot(dx,dy);
        if(d < this.r + p.r){
          const nx=dx/d, ny=dy/d;
          const vdot = this.vx*nx + this.vy*ny;
          if(world.ballType===POW.ASTRAL && world.pierce>0){
            world.pierce--;
            hitPeg(p,true);
            continue;
          }
          this.vx -= 2*vdot*nx;
          this.vy -= 2*vdot*ny;
          this.x = p.x + (this.r+p.r+0.2)*nx;
          this.y = p.y + (this.r+p.r+0.2)*ny;
          hitPeg(p,false);
        }
      }
    }
    collideBucket(){
      const b=world.bucket;
      if(this.y + this.r >= b.y && this.y - this.r <= b.y + b.h && this.x > b.x && this.x < b.x + b.w && this.vy>0){
        this.dead=true;
        world.ballsLeft++;
        world.streak+=3;
        announceStreak(world.streak);
        world.score += 300 * (1 + Math.min(10, world.streak*0.2));
        screenShake(10);
    tone(420,0.12,'triangle',0.04);
    noise(200,.18);
        if(settings.bloodEnabled){ sprayBlood(this.x, this.y, 0.8); } else { spawnSpectralMist(this.x, this.y, 1.4); }
        b.open=false;
        b.anim=12;
      }
    }
    draw(){
      const img = world.ballType===POW.ASTRAL ? Spr.astral
        : world.ballType===POW.VOLTAIC ? Spr.voltaic
        : world.ballType===POW.GRAVEN ? Spr.graven
        : Spr.ball;
      ctx.drawImage(img, this.x-20, this.y-20, 40, 40);
    }
  }

  class Particle{
    constructor(x,y,vx,vy,life,scale,type='blood'){
      this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.life=life; this.scale=scale||1; this.type=type;
    }
    step(){ this.vy += 0.18; this.x += this.vx; this.y += this.vy; this.vx *= 0.99; this.vy *= 0.99; this.life--; }
    draw(){
      const alpha = Math.max(0, this.life/60);
      if(alpha<=0) return;
      ctx.globalAlpha = alpha;
      const s=32*this.scale;
      if(this.type==='blood'){
        ctx.drawImage(Spr.splat, this.x-s/2, this.y-s/2, s, s);
      } else {
        const grd = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, s*0.6);
        if(this.type==='ember'){
          grd.addColorStop(0,'rgba(255,215,134,0.82)');
          grd.addColorStop(1,'rgba(255,111,0,0)');
        } else {
          grd.addColorStop(0,'rgba(186,230,253,0.85)');
          grd.addColorStop(1,'rgba(56,189,248,0)');
        }
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(this.x, this.y, s*0.35, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha=1;
    }
  }

  // ===== Utilities =====
  function clearBlood(){
    world.decals = [];
    world.particles = world.particles.filter(p => p.type !== 'blood');
  }
  function wipeScene(){
    world.decals = [];
    world.particles = [];
  }
  function sprayBlood(x,y,scale=1){
    if(!settings.bloodEnabled) return;
    const density = quality.particleDensity || 1;
    const count = Math.floor(18*quality.mul*scale*density);
    for(let i=0;i<count;i++) world.particles.push(new Particle(x, y, (Math.random()*2-1)*4.6, (Math.random()*2-1)*4.2, 36+Math.random()*30, .6+Math.random()*0.8, 'blood'));
    for(let i=0;i<Math.floor(4*quality.mul*scale*density);i++) addDecal(x+(Math.random()*2-1)*16, y+(Math.random()*2-1)*16);
  }
  function spawnSpectralMist(x,y,scale=1){
    const density = quality.particleDensity || 1;
    const count = Math.floor(12*quality.mul*scale*density);
    const type = (settings.fearEffects && currentFearStage>=3)? 'ember':'wisp';
    for(let i=0;i<count;i++) world.particles.push(new Particle(x, y, (Math.random()*2-1)*3.2, (Math.random()*2-1)*3.2, 40+Math.random()*24, .6+Math.random()*0.5, type));
  }
  function maybeTriggerJumpscare(){ if(jumpscareActive || !settings.fearEffects) return; if(world.fear < 85 || jumpscareCooldown>0) return; if(Math.random()<0.18){ triggerJumpscare(); } }
  function triggerJumpscare(){
    jumpscareActive = true;
    jumpscareCooldown = 600;
    screenShake(26);
    subBoom();
    noise(260, .32);
    tone(1400,0.08,'sawtooth',0.07);
    tone(320,0.25,'square',0.05);
    const layer=document.createElement('div'); layer.className='jumpscare-layer active';
    const face=document.createElement('div'); face.className='jumpscare-face';
    const eyeL=document.createElement('div'); eyeL.className='jumpscare-eye left';
    const eyeR=document.createElement('div'); eyeR.className='jumpscare-eye right';
    const mouth=document.createElement('div'); mouth.className='jumpscare-mouth';
    const tag=document.createElement('div'); tag.className='jumpscare-text';
    const messages=['DO NOT BLINK','IT SEES YOU','FEED THE FEAR','STAY IN THE LIGHT'];
    tag.textContent = messages[Math.floor(Math.random()*messages.length)];
    face.append(eyeL, eyeR, mouth, tag);
    layer.appendChild(face);
    document.body.appendChild(layer);
    document.body.classList.add('fear-flash');
    setTimeout(()=>{ document.body.classList.remove('fear-flash'); }, 600);
    setTimeout(()=>{ layer.remove(); jumpscareActive=false; }, 900);
  }
  function rect(x,y,w,h,fill){ ctx.fillStyle=fill; ctx.fillRect(x,y,w,h); }
  function screenShake(a){ world.screenShake = Math.max(world.screenShake, a); }
  function addDecal(x,y){ if(!settings.bloodEnabled) return; world.decals.push({x,y, s: (24+Math.random()*36)*quality.mul, rot: Math.random()*Math.PI}); if(world.decals.length>Math.floor(240*quality.mul)) world.decals.shift(); }

  // ===== Effects & Hits =====
  function applyPowerup(type, px, py){
    const pow = POW_DATA[type] || POW_DATA[POW.NONE];
    world.ballType = type;
    world.pierce = 0;
    world.chainCharges = 0;
    world.gravenReady = false;
    world.gravity = world.baseGravity;
    if(type===POW.ASTRAL){
      world.pierce = 2;
      world.gravity = world.baseGravity * 0.85;
      tone(760,0.08,'sine',0.04);
    } else if(type===POW.VOLTAIC){
      world.chainCharges = 3;
      tone(520,0.06,'sawtooth',0.05);
    } else if(type===POW.GRAVEN){
      world.gravenReady = true;
      world.gravity = world.baseGravity * 1.15;
      tone(320,0.12,'triangle',0.05);
    }
    showFloat(`Power: ${pow.label}`, px, py, { color:pow.color, glow:'#f472b6', fontSize:18, duration:90, rise:1 });
    updateHUD();
  }

  function triggerVoltaicChain(sourcePeg){
    const radius = 150;
    const candidates = [];
    for(const peg of world.pegs){
      if(peg===sourcePeg || peg.hit) continue;
      const dist = Math.hypot(peg.x - sourcePeg.x, peg.y - sourcePeg.y);
      if(dist <= radius) candidates.push({ peg, dist });
    }
    if(!candidates.length) return;
    candidates.sort((a,b)=>{
      const cursedDiff = (b.peg.type==='cursed') - (a.peg.type==='cursed');
      if(cursedDiff!==0) return cursedDiff;
      return a.dist - b.dist;
    });
    const arcs = candidates.slice(0, Math.min(2, world.chainCharges));
    if(!arcs.length) return;
    noise(160,.18);
    screenShake(5);
    arcs.forEach(({ peg })=>{
      spawnSpectralMist(peg.x, peg.y, 0.6);
      hitPeg(peg, true, true);
    });
  }

  function triggerGravenWell(x, y){
    const radius = 140;
    noise(220,.24);
    subBoom();
    screenShake(10);
    spawnSpectralMist(x, y, 2);
    for(const peg of world.pegs){
      if(peg.hit) continue;
      if(Math.hypot(peg.x - x, peg.y - y) <= radius){
        hitPeg(peg, true, true);
      }
    }
  }

  function dropPowerupChance(px, py){
    const baseChance = 0.1; // rare drop per cursed peg
    if(Math.random()>=baseChance) return;
    const roll = Math.random();
    const type = roll < 0.5 ? POW.ASTRAL : roll < 0.85 ? POW.VOLTAIC : POW.GRAVEN;
    applyPowerup(type, px, py);
  }

  function hitPeg(p, pierce, fromChain=false){
    if(p.type==='steel'){ noise(90,.18); screenShake(3); world.streak=0; lastStreakPing=0; world.score+=5; return; }
    p.hit = true;
    world.streak++;
    announceStreak(world.streak);
    world.score += 60 + world.streak*12;
    noise(120,.22);
    screenShake(6);
    world.fear = Math.min(100, world.fear + 1 + Math.random()*1.8);
    maybeTriggerJumpscare();
    const scale = p.type==='cursed'? 1.25 : 1;
    if(settings.bloodEnabled){
      sprayBlood(p.x, p.y, scale);
      if(p.type==='cursed') spawnSpectralMist(p.x, p.y, 0.6);
    } else {
      spawnSpectralMist(p.x, p.y, scale);
    }
    if(p.type==='cursed'){
      world.clearedCursed++;
      tone(240,0.08,'sawtooth',0.05);
      dropPowerupChance(p.x,p.y);
      if(settings.fearEffects){ if(world.fear>60 && Math.random()<0.35) whisper(); if(world.fear>70) { subBoom(); } }
    }

    if(!fromChain && world.ballType===POW.VOLTAIC){
      triggerVoltaicChain(p);
      world.chainCharges = Math.max(0, world.chainCharges-1);
      if(world.chainCharges<=0){
        world.ballType = POW.NONE;
        world.gravity = world.baseGravity;
        updateHUD();
      } else {
        updateHUD();
      }
    }

    if(!fromChain && world.ballType===POW.GRAVEN && world.gravenReady && (p.type==='cursed' || p.type==='normal')){
      triggerGravenWell(p.x, p.y);
      world.gravenReady = false;
      world.ballType = POW.NONE;
      world.gravity = world.baseGravity;
      updateHUD();
    }

    if(!pierce && world.ballType===POW.ASTRAL && world.pierce<=0){
      world.ballType = POW.NONE;
      world.gravity = world.baseGravity;
      updateHUD();
    }
  }

  function showFloat(text,x,y,opts={}){
    const { color='#facc15', glow='#f43f5e', duration=60, rise=1.2, scale=1, fontSize=16, fontWeight=700, className='' } = opts;
    const div=document.createElement('div');
    div.textContent=text;
    div.className = className;
    div.style.cssText=`position:absolute;left:${x}px;top:${y}px;transform:translate(-50%,-50%) scale(${scale});font-weight:${fontWeight};font-size:${fontSize}px;color:${color};text-shadow:0 0 12px ${glow};pointer-events:none;`; ui.appendChild(div);
    let t=0;
    const id=setInterval(()=>{
      t++;
      div.style.top = (y - t*rise)+'px';
      div.style.opacity = Math.max(0, 1 - t/duration);
      if(t>duration){ clearInterval(id); div.remove(); }
    }, 16);
    return div;
  }

  function announceStreak(streak){
    if(streak<=1 || lastStreakPing===streak) return;
    const important = STREAK_MILESTONES.includes(streak) || (streak>=30 && streak%5===0);
    if(!important) return;
    lastStreakPing = streak;
    showFloat(`Streak Ã—${streak}`, W/2, 120, { color:'#fde68a', glow:'#f97316', fontSize:22, duration:72, rise:1.3, scale:1.1 });
  }

  // ===== Input =====
  const mouse = {x: W/2, y: 60, down:false};
  canvas.addEventListener('mousemove', e=>{
    const r=canvas.getBoundingClientRect();
    const scaleX = r.width ? (canvas.width / r.width) : 1;
    const scaleY = r.height ? (canvas.height / r.height) : 1;
    mouse.x = Math.max(0, Math.min(W, (e.clientX-r.left) * scaleX));
    mouse.y = Math.max(0, Math.min(H, (e.clientY-r.top) * scaleY));
    const dx = mouse.x - W/2, dy = mouse.y - 60;
    world.aim.ang = Math.atan2(dy,dx);
    world.aim.power = Math.min(20, Math.hypot(dx,dy)/30 + 8);
  });
  canvas.addEventListener('mousedown', ()=>{ mouse.down=true; if(state===STATE.PLAY) fire(); else if(state===STATE.MENU) startGame(); else if(state===STATE.BOOT) bootSkip=true; });
  window.addEventListener('mouseup', ()=> mouse.down=false);
  window.addEventListener('keydown', (e)=>{
    if(e.code==='Space'){
      if(ui.querySelector('.menu.story, .menu.tutorial')) return;
      if(state===STATE.MENU && document.getElementById('playBtn')) startGame();
      else if(state===STATE.PLAY) fire();
      else if(state===STATE.BOOT) bootSkip=true;
    }
    if(e.key==='Escape'){
      if(settingsOpen) closeSettings();
      else if(state===STATE.PLAY) openSettings();
    }
    if(e.code==='KeyA' && e.ctrlKey && e.shiftKey){
      settings.adminUnlocked = !settings.adminUnlocked;
      persistSettings();
      const note = settings.adminUnlocked? 'Admin tools unlocked' : 'Admin tools disabled';
      showFloat(note, W/2, H/2, { color:'#facc15', glow:'#fbbf24', duration:90, rise:0, scale:1.2 });
    }
  });

  const handleViewportChange = () => {
    resizeStage();
    checkOrientationLock();
  };
  window.addEventListener('resize', handleViewportChange);
  window.addEventListener('orientationchange', () => setTimeout(handleViewportChange, 120));

  function fire(){ if(!world.aim.ready || world.ballsLeft<=0) return; const a = world.aim.ang; const p = world.aim.power; world.ball = new Ball(W/2, 60, Math.cos(a)*p, Math.sin(a)*p); world.ballsLeft--; world.aim.ready=false; tone(520,0.06,'square',0.045); updateHUD(); }

  // ===== Bucket =====
  function stepBucket(){ const b=world.bucket; b.x += b.vx; if(b.x<20||b.x+b.w>W-20){ b.vx*=-1; } if(b.anim>0){ b.anim--; if(b.anim<=0){ b.open=true; } } }
  function drawBucket(){ const b=world.bucket; const spr = b.open? Spr.bucketOpen : Spr.bucketClosed; const wob = b.open? Math.sin(Date.now()*0.006)*2.5 : 0; ctx.drawImage(spr, b.x, b.y + wob, b.w, b.h); }

  // ===== UI Screens =====
  function setOverlay(html){
    ui.innerHTML = html||'';
    ui.style.pointerEvents = html ? 'auto' : 'none';
    syncHUDVisibility();
  }
  function showBoot(){
    bootStart = performance.now();
    bootProg = 0;
    bootSkip = false;
    bootMsgIdx = 0;
    bootTipIdx = 0;
    lastBootTipChange = bootStart;
    lastBootMsgChange = bootStart;
    const firstMsg = escHTML(bootMsgs[0]);
    const firstTip = escHTML(bootTips[0]);
    setOverlay(`<div class="menu boot"><div class="title">Evil Peggle</div><div class="subtitle">Warming up the haunted stageâ€¦</div><div class="boot-progress"><div class="boot-tip-label">Backstage Tip</div><div class="boot-tip" id="bootTip">${firstTip}</div><div class="progress-bar"><i id="bootFill" style="transform:scaleX(0)"></i></div></div><div class="warn" id="bootMsg">${firstMsg}</div><div class="warn" style="font-size:11px;margin-top:0.8rem">Content warning: flashing lights, jumpscares, and stylized gore. Headphones recommended.</div><div class="flash" style="margin-top:10px">Press SPACE to skip soundcheck (after load)</div></div>`);
  }
  function tickBoot(){
    if(state!==STATE.BOOT) return;
    const now = performance.now();
    if(!bootStart) bootStart = now;
    const elapsed = now - bootStart;
    const fraction = bootSkip ? 1 : Math.min(1, elapsed / BOOT_MIN_MS);
    bootProg = Math.max(bootProg, fraction * 100);
    const fill = document.getElementById('bootFill');
    if(fill) fill.style.transform = `scaleX(${bootProg/100})`;
    if(now - lastBootMsgChange > 2100){
      const msg = document.getElementById('bootMsg');
      if(msg){
        bootMsgIdx = (bootMsgIdx + 1) % bootMsgs.length;
        msg.textContent = bootMsgs[bootMsgIdx];
      }
      lastBootMsgChange = now;
    }
    if(now - lastBootTipChange > 2600){
      const tip = document.getElementById('bootTip');
      if(tip){
        bootTipIdx = (bootTipIdx + 1) % bootTips.length;
        tip.textContent = bootTips[bootTipIdx];
      }
      lastBootTipChange = now;
    }
    if(bootProg >= 100){
      state = STATE.MENU;
      enterAttract();
    }
  }
  function enterAttract(){ ensureDeviceType(()=> ensurePlayerName(()=> startMenu())); }

  function resizeStage(){
    if(!stageEl || !crtEl) return;
    const header = document.querySelector('header');
    const footer = document.querySelector('footer');
    const headerH = header? header.offsetHeight : 0;
    const footerH = footer? footer.offsetHeight : 0;
    const availableWidth = Math.max(320, window.innerWidth - 24);
    const availableHeight = Math.max(320, window.innerHeight - headerH - footerH - 32);
    const scale = Math.min(availableWidth / W, availableHeight / H, 1);
    renderScale = scale > 0 ? scale : 0.1;
    const displayWidth = Math.round(W * renderScale);
    const displayHeight = Math.round(H * renderScale);
    stageEl.style.width = `${displayWidth}px`;
    stageEl.style.height = `${displayHeight}px`;
    stageEl.style.minHeight = `${displayHeight}px`;
    stageEl.style.maxWidth = `${displayWidth}px`;
    stageEl.style.marginTop = `${Math.max(0, (availableHeight - displayHeight)/2)}px`;
    stageEl.style.marginBottom = stageEl.style.marginTop;
    crtEl.style.transform = 'none';
    crtEl.style.width = `${displayWidth}px`;
    crtEl.style.height = `${displayHeight}px`;
    canvas.style.width = `${displayWidth}px`;
    canvas.style.height = `${displayHeight}px`;
    ui.style.width = `${displayWidth}px`;
    ui.style.height = `${displayHeight}px`;
  }

  function ensureDeviceType(done){
    const valid = DEVICE_OPTIONS.some(opt => opt.id === settings.deviceType);
    if(valid){
      checkOrientationLock();
      if(typeof done === 'function') done();
      return;
    }
    stopGame();
    state = STATE.MENU;
    const cards = DEVICE_OPTIONS.map(opt => {
      const label = escHTML(opt.label);
      const note = escHTML(opt.note);
      return `<button class="device-card" data-device="${opt.id}" type="button"><img src="${opt.img}" alt="${label} illustration"><strong>${label}</strong><span>${note}</span></button>`;
    }).join('');
    setOverlay(`<div class="menu device"><div class="title">Choose Your Rig</div><div class="subtitle">How are you summoning the encore tonight?</div><div class="device-carousel-wrapper"><button class="device-nav" id="devicePrev" type="button" aria-label="Previous device">â€¹</button><div class="device-carousel" id="deviceCarousel">${cards}</div><button class="device-nav" id="deviceNext" type="button" aria-label="Next device">â€º</button></div><div class="warn" style="margin-top:1.1rem;font-size:11px">We adjust prompts and orientation for each device.</div></div>`);
    const carousel = document.getElementById('deviceCarousel');
    const prevBtn = document.getElementById('devicePrev');
    const nextBtn = document.getElementById('deviceNext');
    const cardEls = Array.from(carousel?.querySelectorAll('.device-card') || []);
    const setActive = (id) => {
      cardEls.forEach(card => card.classList.toggle('active', card.dataset.device === id));
    };
    const initial = DEVICE_OPTIONS.find(opt => opt.id === settings.deviceType)?.id || DEVICE_OPTIONS[0]?.id;
    if(initial) setActive(initial);
    const centerOn = (id) => {
      if(!carousel) return;
      const card = cardEls.find(c => c.dataset.device === id);
      if(!card) return;
      const offset = card.offsetLeft - (carousel.clientWidth - card.offsetWidth)/2;
      carousel.scrollTo({ left: offset, behavior:'smooth' });
      requestAnimationFrame(updateNavState);
    };
    if(initial) {
      requestAnimationFrame(()=> centerOn(initial));
    }
    const updateNavState = () => {
      if(!carousel || !prevBtn || !nextBtn) return;
      const maxScroll = Math.max(0, carousel.scrollWidth - carousel.clientWidth - 1);
      prevBtn.disabled = carousel.scrollLeft <= 4;
      nextBtn.disabled = carousel.scrollLeft >= maxScroll;
    };
    if(prevBtn){
      prevBtn.addEventListener('click', ()=>{
        if(!carousel) return;
        carousel.scrollBy({ left: -carousel.clientWidth*0.8, behavior:'smooth' });
      });
    }
    if(nextBtn){
      nextBtn.addEventListener('click', ()=>{
        if(!carousel) return;
        carousel.scrollBy({ left: carousel.clientWidth*0.8, behavior:'smooth' });
      });
    }
    carousel?.addEventListener('scroll', () => requestAnimationFrame(updateNavState));
    requestAnimationFrame(updateNavState);
    cardEls.forEach(card => {
      card.addEventListener('click', () => {
        const id = card.dataset.device;
        if(!id) return;
        setActive(id);
        centerOn(id);
        settings.deviceType = id;
        persistSettings();
        setTimeout(()=>{
          setOverlay('');
          resizeStage();
          checkOrientationLock();
          if(typeof done === 'function') done();
        }, 180);
      });
    });
  }

  function showOrientationOverlay(flag){
    if(!orientationOverlay) return;
    const phone = DEVICE_OPTIONS.find(opt => opt.id === 'phone');
    if(flag){
      if(!orientationOverlay.classList.contains('active')){
        orientationOverlay.classList.add('active');
        orientationOverlay.innerHTML = `<div class="orientation-card"><img src="${phone?.img || ''}" alt="Phone illustration" style="transform:rotate(90deg);"><h3>Rotate Device</h3><p>Flip your phone sideways so the bucket beast fits on screen.</p><div class="flash">Turn to landscape to continue</div></div>`;
        if(state === STATE.PLAY){
          orientationBlockState = STATE.PLAY;
          state = STATE.PAUSE;
        }
      }
    } else {
      if(orientationOverlay.classList.contains('active')){
        orientationOverlay.classList.remove('active');
        orientationOverlay.innerHTML = '';
        if(orientationBlockState === STATE.PLAY && state === STATE.PAUSE){
          state = STATE.PLAY;
        }
        orientationBlockState = null;
      }
    }
  }

  function checkOrientationLock(){
    if(settings.deviceType === 'phone'){
      const portrait = window.innerHeight > window.innerWidth;
      showOrientationOverlay(portrait);
    } else {
      showOrientationOverlay(false);
    }
  }

  function ensurePlayerName(done){
    const current = (settings.playerName||'').trim();
    if(current && current !== 'Wanderer'){
      if(typeof done === 'function') done();
      return;
    }
    stopGame();
    state = STATE.MENU;
    const defaultVal = current && current !== 'Wanderer'? current : '';
    setOverlay(`<div class="menu name"><div class="title">State Your Name</div><p>Whisper the alias the carnival will chant.</p><input id="playerNameInputPrimary" maxlength="16" value="${escHTML(defaultVal)}" autocomplete="off" placeholder="Wanderer" /><small>Only letters, numbers, spaces, - _ !</small><div class="row" style="gap:10px"><button class="btn good" id="nameConfirm">âœ” Enter</button><button class="btn" id="nameSkip">Skip</button></div></div>`);
    const input = document.getElementById('playerNameInputPrimary');
    const sanitize = (val)=> val.replace(/[^a-z0-9 _!\-]/gi,'').slice(0,16);
    if(input){
      input.focus();
      input.addEventListener('input', (e)=>{ e.target.value = sanitize(e.target.value); });
      input.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ document.getElementById('nameConfirm')?.click(); }});
    }
    const commit = (raw)=>{
      const value = sanitize(raw).trim();
      settings.playerName = value || 'Wanderer';
      persistSettings();
      refreshPlayerBadge();
      setOverlay('');
      if(typeof done === 'function') done();
    };
    document.getElementById('nameConfirm')?.addEventListener('click', ()=> commit(input?.value||''));
    document.getElementById('nameSkip')?.addEventListener('click', ()=> commit('Wanderer'));
  }

  function showStoryIntro({ markSeen=false, onComplete }={}){
    stopGame();
    state = STATE.MENU;
    const name = escHTML(settings.playerName || 'Wanderer');
    const slides = [
      { title:'Backstage Note', body:[`${name}, the headlinerâ€™s gone and the crowd is restless.`, 'Each cursed peg holds the chorus hostage â€” crack them to keep the show alive.'] },
      { title:'Encore Rules', body:['Launch the haunted eyeball and clear every crimson peg before you run out of shots.', 'Catch the bucket beast to recover a ball. Miss, and the pit will swallow you.'] },
      { title:'Fear Meter', body:['Streaks fuel the Fear bar. Higher fear twists the arena with lights, whispers, and power.', 'Stay focused. The bandâ€™s finale depends on your aim.'] }
    ];
    const total = slides.length;
    let idx = 0;
    const finish = () => {
      if(markSeen){ settings.storySeen = true; persistSettings(); }
      setOverlay('');
      if(typeof onComplete === 'function'){ onComplete(); }
      else { startMenu(); }
    };
    const render = () => {
      const slide = slides[idx];
      const paragraphs = slide.body.map(line => `<p>${escHTML(line)}</p>`).join('');
      const progress = `<div class="story-progress">${idx+1} / ${total}</div>`;
      const isLast = idx === total-1;
      setOverlay(`<div class="menu story"><div class="title">${slide.title}</div>${progress}${paragraphs}<div class="row" style="gap:12px"><button class="btn" id="storySkip">âœ– Skip</button><button class="btn good" id="storyNext">${isLast? 'âœ” Begin':'â–¶ Next'}</button></div></div>`);
      document.getElementById('storySkip').onclick = finish;
      document.getElementById('storyNext').onclick = () => {
        if(isLast){ finish(); }
        else { idx++; render(); }
      };
    };
    render();
  }

  function showCredits(){
    stopGame();
    state = STATE.MENU;
    const html = `
      <div class="menu story">
        <div class="title">Credits</div>
        <p>Version ${VERSION}</p>
        <ul style="list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:6px;font-size:14px;text-align:left">
          <li><strong>Creative Direction &amp; Art</strong>: Alex Johnston</li>
          <li><strong>Engineering &amp; Audio Design</strong>: ChatGPT (OpenAI Codex)</li>
          <li><strong>Inspired by</strong>: Peggle, PopCap Games</li>
          <li><strong>Fonts</strong>: Cinzel, Inter</li>
        </ul>
        <div class="warn" style="margin-top:12px">Thanks for aiming true and feeding the fear.</div>
        <div class="row" style="gap:12px"><button class="btn good" id="creditsBack">âœ” Return</button></div>
      </div>`;
    setOverlay(html);
    document.getElementById('creditsBack')?.addEventListener('click', () => startMenu());
  }

  function showLevelLab(){
    stopGame();
    state = STATE.MENU;

    const render = () => {
      const entries = getCustomLevelEntries();
      const list = entries.length
        ? entries.map(entry => {
            const time = entry.updated ? new Date(entry.updated).toLocaleString() : 'â€”';
            return `<div class="setting-tile" style="flex-direction:column;align-items:stretch;gap:8px" data-name="${escHTML(entry.name)}">
              <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
                <div>
                  <span style="font-weight:700;letter-spacing:.08em;text-transform:uppercase;font-size:11px">${escHTML(entry.name)}</span>
                  <div style="font-size:11px;color:rgba(226,232,240,.7)">${time}</div>
                </div>
                <div style="display:flex;gap:6px">
                  <button class="btn" data-action="play">â–¶ Play</button>
                  <button class="btn" data-action="copy">â§‰ Copy</button>
                  <button class="btn danger" data-action="delete">âœ– Delete</button>
                </div>
              </div>
            </div>`;
          }).join('')
        : '<div class="warn">No custom levels saved yet. Paste JSON below or export the current board.</div>';

      setOverlay(`
        <div class="menu story level-lab" style="max-width:640px;width:100%;display:flex;flex-direction:column;gap:18px">
          <div class="title">Level Lab (Beta)</div>
          <p>Import, save, and launch custom layouts. Share the JSON blob with friends to trade horrors.</p>
          <section class="settings-section" style="gap:12px">
            <h3>Saved Levels</h3>
            <div id="labList" style="display:flex;flex-direction:column;gap:10px;max-height:220px;overflow:auto">${list}</div>
          </section>
          <section class="settings-section" style="gap:12px">
            <h3>Editor</h3>
            <label style="display:flex;flex-direction:column;gap:6px;font-size:12px;letter-spacing:.08em;text-transform:uppercase;color:#fda4af">
              Level Name
              <input type="text" id="labName" value="${escHTML(customSessionName || 'Custom Draft')}" maxlength="48" style="padding:.6rem .8rem;border-radius:12px;border:1px solid rgba(248,113,113,.28);background:rgba(20,20,26,.92);color:#f8fafc;font-weight:600">
            </label>
            <textarea id="labData" spellcheck="false" style="min-height:160px;padding:12px;border-radius:12px;border:1px solid rgba(248,113,113,.28);background:rgba(16,16,22,.92);color:#f8fafc;font-family:'Courier New',monospace;font-size:12px"></textarea>
            <div class="settings-actions minor" style="gap:8px">
              <button class="btn" id="labExport">â§‰ Export Current</button>
              <button class="btn good" id="labSave">ðŸ’¾ Save</button>
              <button class="btn" id="labPlayTemp">â–¶ Play Once</button>
            </div>
            <div class="warn" id="labMessage"></div>
          </section>
          <div class="row" style="gap:12px"><button class="btn" id="labBack">â† Back</button></div>
        </div>`);

      attach(entries);
    };

    const parseLevelPayload = (text) => {
      if(!text) return [];
      try{
        const json = JSON.parse(text);
        if(Array.isArray(json)) return json;
        if(json && Array.isArray(json.pegs)) return json.pegs;
      } catch(err){
        console.warn('Failed to parse level payload', err);
      }
      return [];
    };

    const attach = (entries) => {
      const nameInput = document.getElementById('labName');
      const dataInput = document.getElementById('labData');
      const messageEl = document.getElementById('labMessage');

      const showMsg = (msg, color='#facc15') => {
        if(messageEl){
          messageEl.textContent = msg;
          messageEl.style.color = color;
        }
      };

      document.getElementById('labExport')?.addEventListener('click', ()=>{
        const payload = { version: VERSION, pegs: serializeCurrentLevel() };
        dataInput.value = JSON.stringify(payload, null, 2);
        showMsg('Current level exported to JSON.');
      });

      document.getElementById('labSave')?.addEventListener('click', ()=>{
        const payload = parseLevelPayload(dataInput.value.trim());
        if(!payload.length){ showMsg('Paste or export a level first.', '#f87171'); return; }
        const key = saveCustomLevel(nameInput.value, payload);
        showMsg(`Saved custom level: ${key}`);
        render();
      });

      document.getElementById('labPlayTemp')?.addEventListener('click', ()=>{
        const payload = parseLevelPayload(dataInput.value.trim());
        if(!payload.length){ showMsg('Need valid level data to play.', '#f87171'); return; }
        customSessionName = nameInput.value.trim() || 'Custom Draft';
        setOverlay('');
        loadCustomLayout(payload);
        gameMode = MODE.FREEPLAY;
        world.score = 0;
        state = STATE.PLAY;
        world.aim.ready = true;
        syncHUDVisibility();
      });

      document.getElementById('labBack')?.addEventListener('click', ()=> startMenu());

      const listEl = document.getElementById('labList');
      listEl?.querySelectorAll('.setting-tile').forEach(tile => {
        const name = tile.dataset.name;
        tile.addEventListener('click', e => {
          const action = e.target?.dataset?.action;
          if(!action) return;
          e.stopPropagation();
          if(action==='play'){
            startCustomLevel(name);
          } else if(action==='delete'){
            deleteCustomLevel(name);
            render();
          } else if(action==='copy'){
            const entry = customLevels[name];
            if(!entry) return;
            const text = JSON.stringify({ version: VERSION, pegs: entry.pegs }, null, 2);
            dataInput.value = text;
            nameInput.value = entry.name;
            if(navigator.clipboard){ navigator.clipboard.writeText(text).catch(()=>{}); }
            showMsg(`Copied ${name} to editor.`);
          }
        });
      });
    };

    render();
  }

  function startMenu(){
    customSessionName = null;
    if(state===STATE.PLAY && gameMode===MODE.STORY){
      settings.storyProgress = Math.max(1, Math.min(TOTAL_LEVELS, world.level));
      persistSettings();
    }
    stopGame();
    state=STATE.MENU;
    gameMode = MODE.STORY;
    const hint = MENU_HINTS[Math.floor(Math.random()*MENU_HINTS.length)];
    const scoreHtml = renderScoreList();
    const freeplayLocked = !settings.storyCleared && settings.storyProgress <= 1;
    const freeplayButton = freeplayLocked
      ? '<button class="btn" id="freeplayBtn" disabled title="Finish Story Run to unlock">ðŸ”’ Freeplay</button>'
      : '<button class="btn" id="freeplayBtn">ðŸŽ¯ Freeplay</button>';
    const lockNote = freeplayLocked? '<div class="warn" style="font-size:11px">Beat level 1 in Story Run to unlock Freeplay.</div>' : '';
    const resumeLabel = settings.storyProgress>1 && settings.storyProgress<=TOTAL_LEVELS? `Continue (Level ${settings.storyProgress})` : 'â–¶ Story Run';
    setOverlay(`<div class="menu"><div class="title">Evil Peggle</div><div class="subtitle">Choose your torment</div><div class="row" style="gap:10px;flex-wrap:wrap"><button class="btn play good" id="playBtn">${resumeLabel}</button>${freeplayButton}<button class="btn" id="loreBtn">â„¹ How to Play</button><button class="btn" id="creditsBtn">ðŸ“œ Credits</button></div><div class="score-list-title">Personal Best</div>${scoreHtml}${lockNote}<div class="warn">${hint}</div><div class="flash">PRESS SPACE</div></div>`);
    document.getElementById('playBtn').onclick=()=> startGame();
    const freeBtn=document.getElementById('freeplayBtn');
    if(freeBtn && !freeplayLocked) freeBtn.onclick = () => showFreeplayMenu();
    const loreBtn=document.getElementById('loreBtn');
    if(loreBtn) loreBtn.onclick = () => showStoryIntro({ markSeen:false, onComplete:startMenu });
    const creditsBtn=document.getElementById('creditsBtn');
    if(creditsBtn) creditsBtn.onclick = () => showCredits();
  }
  function startGame(){
    stopGame();
    gameMode = MODE.STORY;
    const canResume = settings.storyProgress>1 && settings.storyProgress<=TOTAL_LEVELS;
    state=STATE.PLAY;
    setOverlay('');
    tutorialShown = false;
    if(canResume){
      loadLevel(settings.storyProgress);
    } else {
      world.score = 0;
      settings.storyProgress = 1;
      persistSettings();
      loadLevel(1);
    }
    updateHUD();
    world.aim.ready=true;
    syncHUDVisibility();
  }

  function showFreeplayMenu(){
    stopGame();
    state=STATE.MENU;
    world.aim.ready=false;
    const unlockedCount = settings.storyCleared ? TOTAL_LEVELS : Math.max(0, Math.min(TOTAL_LEVELS, settings.storyProgress - 1));
    if(unlockedCount<=0){
      setOverlay(`<div class="menu"><div class="title">Freeplay Locked</div><div class="subtitle">Beat a level in Story Run first</div><button class="btn" id="lockedBack">â† Back</button></div>`);
      document.getElementById('lockedBack')?.addEventListener('click', ()=> startMenu());
      return;
    }
    const cards = Array.from({length: unlockedCount}, (_,i)=>{
      const level=i+1;
      return `<button type="button" class="score-card" data-level="${level}">Level ${level}<span>Best ${formatScore(getBestScore(level))}</span></button>`;
    }).join('');
    const totalNote = unlockedCount < TOTAL_LEVELS && !settings.storyCleared ? `<div class="warn" style="font-size:11px">Clear more Story levels to unlock additional Freeplay hunts.</div>` : '';
    setOverlay(`<div class="menu"><div class="title">Freeplay</div><div class="subtitle">Pick a level to replay</div><div class="score-list" style="max-height:240px;width:100%;max-width:420px;overflow:auto">${cards}</div>${totalNote}<div class="row" style="gap:10px"><button class="btn" id="freeplayBack">â† Back</button></div></div>`);
    document.querySelectorAll('.score-card').forEach(btn=>{
      btn.onclick = ()=> startFreeplay(Number(btn.dataset.level));
    });
    const back=document.getElementById('freeplayBack');
    if(back) back.onclick = () => startMenu();
  }

  function startFreeplay(level){
    freeplayLevel = level;
    customSessionName = null;
    gameMode = MODE.FREEPLAY;
    tutorialShown = true;
    world.score = 0;
    state = STATE.PLAY;
    setOverlay('');
    loadLevel(level);
    updateHUD();
    world.aim.ready = true;
    syncHUDVisibility();
  }

  function startCustomLevel(name){
    const entry = customLevels[name];
    if(!entry){
      showFloat('Missing custom level', W/2, H/2, { color:'#f87171', glow:'#7f1d1d', duration:90, rise:0 });
      return;
    }
    const pegs = deserializePegs(entry.pegs || []);
    customSessionName = entry.name || name;
    freeplayLevel = 0;
    gameMode = MODE.FREEPLAY;
    tutorialShown = true;
    world.score = 0;
    state = STATE.PLAY;
    setOverlay('');
    loadCustomLayout(pegs);
    updateHUD();
    world.aim.ready = true;
    syncHUDVisibility();
  }

  function showFreeplayResult(levelScore){
    stopGame();
    state = STATE.MENU;
    world.aim.ready = false;
    if(customSessionName){
      setOverlay(`<div class="menu"><div class="title">${escHTML(customSessionName)} Cleared</div><div class="subtitle">Score ${formatScore(levelScore)}</div><div class="row" style="gap:10px"><button class="btn good" id="freeplayReplay">â†º Encore</button><button class="btn" id="freeplaySelect">ðŸ§ª Level Lab</button><button class="btn" id="freeplayMenu">â˜° Menu</button></div></div>`);
      document.getElementById('freeplayReplay').onclick = () => startCustomLevel(customSessionName);
      document.getElementById('freeplaySelect').onclick = () => showLevelLab();
      document.getElementById('freeplayMenu').onclick = () => startMenu();
    } else {
      const best = formatScore(getBestScore(freeplayLevel));
      setOverlay(`<div class="menu"><div class="title">Level ${freeplayLevel} Cleared</div><div class="subtitle">Score ${formatScore(levelScore)}</div><div class="warn">Personal best: ${best}</div><div class="row" style="gap:10px"><button class="btn good" id="freeplayReplay">â†º Encore</button><button class="btn" id="freeplaySelect">ðŸŽ¯ Levels</button><button class="btn" id="freeplayMenu">â˜° Menu</button></div></div>`);
      document.getElementById('freeplayReplay').onclick = () => startFreeplay(freeplayLevel);
      document.getElementById('freeplaySelect').onclick = () => showFreeplayMenu();
      document.getElementById('freeplayMenu').onclick = () => startMenu();
    }
  }
  function showGameOver(){
    stopGame();
    const final = Math.floor(world.score);
    settings.storyProgress = 1;
    persistSettings();
    setOverlay(`<div class="menu"><div class="title">Crowd Booed You Off</div><div class="subtitle">Final score <b>${final}</b> Â· Level ${world.level}</div><div class="row" style="gap:10px"><button class="btn good" id="retryBtn">â†º Encore</button><button class="btn" id="menuBtn">â˜° Backstage</button></div></div>`);
    document.getElementById('retryBtn').onclick=()=>{ setOverlay(''); state=STATE.PLAY; world.score=0; settings.storyProgress=1; persistSettings(); loadLevel(1); updateHUD(); world.aim.ready=true; syncHUDVisibility(); };
    document.getElementById('menuBtn').onclick=()=> startMenu();
  }

  function showStoryComplete(finalScore){
    stopGame();
    state = STATE.MENU;
    settings.storyCleared = true;
    settings.storyProgress = 1;
    persistSettings();
    const formatted = formatScore(finalScore);
    setOverlay(`<div class="menu"><div class="title">Encore Complete</div><div class="subtitle">Total score <b>${formatted}</b></div><div class="warn">Freeplay unlocked! Revisit any haunt for better scores.</div><div class="row" style="gap:10px"><button class="btn good" id="storyReplay">â–¶ Replay Story</button><button class="btn" id="storyFreeplay">ðŸŽ¯ Freeplay</button><button class="btn" id="storyMenu">â˜° Menu</button></div></div>`);
    document.getElementById('storyReplay').onclick = () => startGame();
    document.getElementById('storyFreeplay').onclick = () => showFreeplayMenu();
    document.getElementById('storyMenu').onclick = () => startMenu();
  }

  function showFreeplayLoss(){
    stopGame();
    state = STATE.MENU;
    world.aim.ready=false;
    const levelScore = Math.max(0, Math.floor(world.score));
    if(customSessionName){
      setOverlay(`<div class="menu"><div class="title">Encore Failed</div><div class="subtitle">${escHTML(customSessionName)} Â· Score ${formatScore(levelScore)}</div><div class="row" style="gap:10px"><button class="btn good" id="freeplayEncore">â†º Encore</button><button class="btn" id="freeplayLevels">ðŸ§ª Level Lab</button><button class="btn" id="freeplayMenuLoss">â˜° Menu</button></div></div>`);
      document.getElementById('freeplayEncore').onclick = () => startCustomLevel(customSessionName);
      document.getElementById('freeplayLevels').onclick = () => showLevelLab();
      document.getElementById('freeplayMenuLoss').onclick = () => startMenu();
    } else {
      const best = formatScore(getBestScore(freeplayLevel));
      setOverlay(`<div class="menu"><div class="title">Encore Failed</div><div class="subtitle">Level ${freeplayLevel} Â· Score ${formatScore(levelScore)}</div><div class="warn">Personal best: ${best}</div><div class="row" style="gap:10px"><button class="btn good" id="freeplayEncore">â†º Encore</button><button class="btn" id="freeplayLevels">ðŸŽ¯ Levels</button><button class="btn" id="freeplayMenuLoss">â˜° Menu</button></div></div>`);
      document.getElementById('freeplayEncore').onclick = () => startFreeplay(freeplayLevel);
      document.getElementById('freeplayLevels').onclick = () => showFreeplayMenu();
      document.getElementById('freeplayMenuLoss').onclick = () => startMenu();
    }
  }

  // ===== Draw helpers =====
  function drawBG(){
    ctx.drawImage(Spr.bg, 0, 0, W, H);
    const flick = 0.05 + Math.sin(Date.now()*0.0023)*0.025;
    ctx.save();
    ctx.globalAlpha = flick;
    const flare = ctx.createRadialGradient(W/2, 70, 60, W/2, 70, 460);
    flare.addColorStop(0, 'rgba(239,68,68,.38)');
    flare.addColorStop(0.45, 'rgba(127,29,29,.22)');
    flare.addColorStop(1, 'rgba(0,0,0,0)');
    rect(0, 0, W, H, flare);
    ctx.globalAlpha = 0.28 * flick;
    const abyss = ctx.createLinearGradient(0, H*0.55, 0, H);
    abyss.addColorStop(0, 'rgba(12,0,20,0)');
    abyss.addColorStop(1, 'rgba(5,0,12,.65)');
    rect(0, 0, W, H, abyss);
    if(currentFearStage>=3){
      const bands = currentFearStage===3? 3 : 5;
      ctx.globalAlpha = 0.05 + (currentFearStage-2)*0.04;
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      for(let i=0;i<bands;i++){
        const h = 4 + Math.random()*8;
        const y = Math.random()*H;
        ctx.fillRect(0, y, W, h);
      }
    }
    ctx.restore();
  }
  function drawDecals(){
    if(!settings.bloodEnabled) return;
    for(const d of world.decals){ ctx.save(); ctx.globalAlpha=.8; ctx.translate(d.x, d.y); ctx.rotate(d.rot); ctx.drawImage(Spr.splat, -d.s/2, -d.s/2, d.s, d.s); ctx.restore(); }
  }
  function drawPegs(){ const t=Date.now()*0.008; for(const p of world.pegs){ if(p.hit) continue; const wob = Math.sin(p.t + t)* (p.type==='cursed'? 1.5:0.6); const img = p.type==='cursed'? (Math.sin(t*3+p.t)>0? Spr.cursedA: Spr.cursedB) : (p.type==='steel'? Spr.steel : Spr.meat); ctx.drawImage(img, p.x-22+wob, p.y-22, 44, 44); } }
  function drawHallucinations(){ if(!settings.fearEffects || world.fear<60) return; const density = quality.hallucinationRate || 1; const baseCount = Math.min(10, Math.floor((world.fear-60)/4)); const count = Math.floor(baseCount * density); // generate positions if needed
    while(world.hallucinations.length<count){ world.hallucinations.push({x:Math.random()*W, y:120+Math.random()*(H-220), r:20, t:Math.random()*100}); }
    ctx.save(); ctx.globalAlpha = 0.28 + Math.random()*0.12; for(const h of world.hallucinations){ const wob=Math.sin(h.t + Date.now()*0.008)*1.2; ctx.drawImage(Spr.cursedA, h.x-22+wob, h.y-22, 44, 44); } ctx.restore(); }
  function drawAimer(){
    if(!world.aim.ready) return;
    const a=world.aim.ang; const p=world.aim.power; const tx=W/2+Math.cos(a)*p*5, ty=60+Math.sin(a)*p*5;
    const readyImg = world.ballType===POW.ASTRAL? Spr.astral
      : world.ballType===POW.VOLTAIC? Spr.voltaic
      : world.ballType===POW.GRAVEN? Spr.graven
      : Spr.ball;
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.drawImage(readyImg, W/2-20, 36, 40, 40);
    if(world.fear>70){ ctx.filter='contrast(140%) saturate(120%) blur(1px)'; }
    ctx.setLineDash([6,6]);
    ctx.lineDashOffset = - (Date.now()*0.05 % 12);
    ctx.beginPath();
    ctx.moveTo(W/2, 60);
    ctx.lineTo(tx, ty);
    ctx.strokeStyle='#f43f5e';
    ctx.lineWidth=2;
    ctx.stroke();
    ctx.filter='none';
    ctx.restore();
  }

  function getFearStage(value){
    for(let i=FEAR_STAGES.length-1;i>=0;i--){ if(value >= FEAR_STAGES[i].threshold) return i; }
    return 0;
  }

  function setFearStage(stage){
    const prev = currentFearStage;
    const meta = FEAR_STAGES[stage] || FEAR_STAGES[0];
    if(stage === prev){
      if(fearStageLabel) fearStageLabel.textContent = meta.label;
      return;
    }
    currentFearStage = stage;
    if(fearWidget){
      FEAR_STAGES.forEach((s,idx)=> fearWidget.classList.toggle(s.className, idx===stage));
    }
    if(fearStageLabel){ fearStageLabel.textContent = meta.label; }
    document.body.dataset.fear = stage;
    if(stage > prev && prev >= 0 && settings.fearEffects){
      showFloat(`FEAR: ${meta.label}`, W/2, 90, { color:'#fecdd3', glow:'#f472b6', fontSize:20, duration:80, rise:1.1, scale:1.05 });
      if(stage>=4) maybeTriggerJumpscare();
      if(stage>=2) whisper();
      if(stage>=4) subBoom();
    }
  }

  function updateHUD(){
    ballsLabel.textContent = world.ballsLeft;
    scoreLabel.textContent = Math.floor(world.score);
    if(streakLabel) streakLabel.textContent = world.streak;
    if(cursedLabel) cursedLabel.textContent = `${Math.max(0, world.totalCursed - world.clearedCursed)} / ${world.totalCursed||0}`;
    levelLabel.textContent = world.level;
    const fearPct = Math.round(world.fear);
    fearLabel.textContent = fearPct + '%';
    if(fearFill){ fearFill.style.transform = `scaleX(${Math.min(1, Math.max(0, fearPct/100))})`; }
    setFearStage(getFearStage(fearPct));
    const powMeta = POW_DATA[world.ballType] || POW_DATA[POW.NONE];
    let powerText = powMeta.short;
    if(world.ballType===POW.ASTRAL){ powerText += ` Ã—${Math.max(0, world.pierce)}`; }
    else if(world.ballType===POW.VOLTAIC){ powerText += ` âš¡${Math.max(0, world.chainCharges)}`; }
    else if(world.ballType===POW.GRAVEN){ powerText += world.gravenReady ? ' Ready' : ''; }
    if(powerLabel){
      powerLabel.textContent = powerText;
      powerLabel.style.color = powMeta.color;
      powerLabel.style.opacity = world.ballType===POW.NONE? 0.7 : 1;
      powerLabel.title = `${powMeta.label}${powMeta.desc? ` â€” ${powMeta.desc}`:''}`;
    }
    const prog = world.totalCursed? world.clearedCursed/world.totalCursed : 0;
    progressFill.style.transform = `scaleX(${Math.min(1, Math.max(0, prog))})`;
  }

  function checkEnd(){
    if(world.clearedCursed >= world.totalCursed){
      sting();
      const k = Math.floor(220*quality.mul);
      const type = settings.bloodEnabled? 'blood' : 'ember';
      for(let i=0;i<k;i++) world.particles.push(new Particle(W/2, H-120, (Math.random()*2-1)*6, -Math.random()*5-2, 60+Math.random()*40, .8+Math.random()*0.8, type));
      world.score += 1200 + world.ballsLeft*140;
      const levelScore = Math.max(0, Math.floor(world.score));
      recordBest(world.level, levelScore);
      updateHUD();
      if(gameMode === MODE.STORY){
        settings.storyProgress = world.level;
        persistSettings();
      }
      if(gameMode === MODE.FREEPLAY){
        world.ball = null;
        showFreeplayResult(levelScore);
      } else {
        world.level++;
        if(world.level > TOTAL_LEVELS){
          showStoryComplete(Math.floor(world.score));
        } else {
          loadLevel(world.level);
        }
      }
    } else if(world.ball?.dead){
      world.ball=null;
      world.aim.ready=true;
      world.streak=0;
      lastStreakPing=0;
      if(world.ballsLeft<=0){
        if(gameMode === MODE.FREEPLAY){
          showFreeplayLoss();
        } else {
          state=STATE.GAMEOVER; showGameOver();
        }
      }
    }
  }

  function withShake(draw){ if(world.screenShake>0){ world.screenShake*=0.9; const s=world.screenShake; const dx=(Math.random()*2-1)*s, dy=(Math.random()*2-1)*s; ctx.save(); ctx.translate(dx,dy); draw(); ctx.restore(); } else draw(); }

  // ===== Loop =====
  function loop(){ requestAnimationFrame(loop);
    if(state===STATE.BOOT){ drawBG(); tickBoot(); return; }
    if(state===STATE.MENU){ drawBG(); return; }
    if(state===STATE.PAUSE){
      withShake(()=>{ drawBG(); drawHallucinations(); drawDecals(); drawBucket(); drawPegs(); world.ball?.draw(); drawAimer(); });
      updateHUD();
      return;
    }
    withShake(()=>{ if(world.fear>70) ctx.filter='contrast(140%) saturate(115%) blur(1px)'; drawBG(); ctx.filter='none'; drawHallucinations(); drawDecals(); stepBucket(); drawBucket(); drawPegs(); world.ball?.step(); for(let i=world.particles.length-1;i>=0;i--){ const pt=world.particles[i]; pt.step(); pt.draw(); if(pt.life<=0 || pt.y>H+60) world.particles.splice(i,1); } world.ball?.draw(); drawAimer(); });
    if(state===STATE.PLAY){ if(world.fear>0){ const stage = getFearStage(world.fear); const decay = Math.max(0.004, 0.012 - stage*0.0025); world.fear = Math.max(0, world.fear - decay); } checkEnd(); }
    updateHUD();
    if(jumpscareCooldown>0) jumpscareCooldown--;
  }

  // ===== Reset/Button actions =====

  // ===== Boot & start =====
  resizeStage();
  showBoot();
  checkOrientationLock();
  setInterval(()=>{ if(state===STATE.BOOT) tickBoot(); }, 40);
  loop();
})();
</script>
</body>
</html>
    if(musicSlider){
      updateRangeFill(musicSlider);
      musicSlider.addEventListener('input', e => {
        const value = clamp01(parseFloat(e.target.value));
        settings.musicVolume = value;
        if(musicValue) musicValue.textContent = `${Math.round(value*100)}%`;
        updateRangeFill(e.target);
        persistSettings();
        updateMusicGain();
      });
    }
    if(effectsSlider){
      updateRangeFill(effectsSlider);
      effectsSlider.addEventListener('input', e => {
        const value = clamp01(parseFloat(e.target.value));
        settings.effectsVolume = value;
        if(effectsValue) effectsValue.textContent = `${Math.round(value*100)}%`;
        updateRangeFill(e.target);
        persistSettings();
      });
    }
