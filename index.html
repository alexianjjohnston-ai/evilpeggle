<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Evil Peggle</title>
  <style>
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0a0a0f 0%, #050508 55%, #020204 100%);color:#f7edff;font:14px/1.45 "Inter", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", Helvetica, Arial}
    .wrap{display:grid;grid-template-rows:auto 1fr auto;height:100%;background:radial-gradient(circle at 50% 115%, rgba(160,24,32,.24), rgba(4,4,6,0) 65%)}
    header{display:flex;align-items:center;gap:1rem;padding:.7rem 1.2rem;background:rgba(18,18,20,.92);border-bottom:1px solid rgba(239,68,68,.45);backdrop-filter:blur(12px);box-shadow:0 18px 36px rgba(0,0,0,.45);position:sticky;top:0;z-index:20}
    header h1{margin:0;font:600 13px/1.2 "Cinzel", Trajan, serif;letter-spacing:.28em;text-transform:uppercase;color:#fde68a;text-shadow:0 0 12px rgba(239,68,68,.6)}
    header .sp{flex:1}
    .btn, select{cursor:pointer;user-select:none;border:1px solid rgba(148,163,184,.25);background:rgba(28,29,34,.88);border-radius:12px;padding:.5rem .85rem;display:inline-flex;align-items:center;gap:.5rem;color:#f9fafb;font-weight:600;letter-spacing:.02em;box-shadow:0 8px 18px rgba(0,0,0,.35);transition:background .2s ease, transform .2s ease}
    .btn:hover, select:hover{background:rgba(38,39,46,.94);transform:translateY(-1px)}
    .btn:active{transform:translateY(1px)}
    select{appearance:none;padding-right:1.6rem;background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="7"><path fill="%23e5e7eb" d="M1 1l5 5 5-5"/></svg>');background-repeat:no-repeat;background-position:right .6rem center}
    .danger{border-color:rgba(239,68,68,.55);background:rgba(127,29,29,.9);color:#fee2e2}
    .good{border-color:rgba(248,113,113,.35);background:rgba(153,27,27,.82);color:#fee2e2}
    .row{display:flex;align-items:center;gap:.6rem}
    main{display:grid;place-items:center;padding:0.5rem clamp(0.5rem,2vw,1rem)}

    /* CRT look */
    .crt{position:relative;width:min(960px,100%);margin:0 auto}
    .crt:before{content:"";position:absolute;inset:0;pointer-events:none;background:repeating-linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.03) 1px, transparent 1px, transparent 3px)}
    .crt:after{content:"";position:absolute;inset:0;pointer-events:none;box-shadow:inset 0 0 200px rgba(0,0,0,.82)}
    body[data-fear='3'] .crt:after{box-shadow:inset 0 0 240px rgba(185,28,28,.55)}
    body[data-fear='4'] .crt:after{box-shadow:inset 0 0 320px rgba(220,20,60,.65)}
    body[data-fear='4'] canvas{filter:saturate(1.12) contrast(1.05)}

    canvas{display:block;width:100%;height:auto;background:#060608;border:1px solid rgba(248,113,113,.25);border-radius:22px;box-shadow:0 28px 90px rgba(0,0,0,.78)}

    .hud-layer{position:absolute;inset:0;display:flex;flex-direction:column;justify-content:flex-start;padding:18px 24px 14px;pointer-events:none;color:#f9eeff;text-shadow:0 0 12px rgba(255,255,255,.12);opacity:1;transition:opacity .2s ease}
    .hud-top{display:flex;justify-content:space-between;align-items:flex-start;gap:1.2rem;flex-wrap:wrap}
    .hud-bottom{margin-top:auto;display:flex;justify-content:space-between;align-items:flex-end;gap:1.2rem;flex-wrap:wrap}
    .hud-cluster{display:flex;gap:.6rem;flex-wrap:wrap;align-items:flex-start}
    .hud-chip{min-width:60px;padding:.2rem .35rem;border-radius:8px;border:0;background:transparent;box-shadow:none;pointer-events:none}
    .hud-chip .label{display:block;font-size:10px;letter-spacing:.16em;text-transform:uppercase;color:rgba(248,113,113,.8);margin-bottom:2px;text-shadow:0 0 6px rgba(0,0,0,.6)}
    .hud-chip .value{display:block;font-size:20px;font-weight:700;color:#ffffff;text-shadow:0 0 12px rgba(0,0,0,.6)}
    .hud-progress{display:flex;flex-direction:column;gap:4px;min-width:200px}
    .hud-progress .progress-bar{width:100%;height:10px}
    .hud-chip.tight{min-width:64px}
    .hud-chip.wide{min-width:120px;text-align:center}

    .fear-widget{pointer-events:none;display:flex;flex-direction:column;align-items:center;gap:.35rem;padding:.35rem .6rem;border-radius:14px;border:0;background:transparent;box-shadow:none}
    .fear-widget .label{font-size:11px;letter-spacing:.26em;text-transform:uppercase;color:rgba(248,113,113,.8);text-shadow:0 0 6px rgba(0,0,0,.6)}
    .fear-widget .tier{font-size:12px;letter-spacing:.18em;text-transform:uppercase;color:#ffe4e6;text-shadow:0 0 10px rgba(0,0,0,.75)}
    .fear-widget .value{font-size:18px;font-weight:700;color:#ffffff;text-shadow:0 0 18px rgba(0,0,0,.8)}
    .fear-bar{width:min(260px,48vw);height:12px;border-radius:999px;background:rgba(12,13,16,.82);border:1px solid rgba(248,113,113,.3);overflow:hidden;position:relative;box-shadow:inset 0 0 12px rgba(0,0,0,.55)}
    .fear-bar>i{position:absolute;inset:0;background:linear-gradient(90deg,#f87171,#ef4444,#b91c1c);transform-origin:left center;transform:scaleX(0);transition:transform .25s ease}
    .fear-widget.fear-0{border-color:rgba(248,113,113,.45)}
    .fear-widget.fear-1{border-color:rgba(248,113,113,.6);box-shadow:0 18px 40px rgba(248,113,113,.28)}
    .fear-widget.fear-2{border-color:rgba(220,38,38,.65);box-shadow:0 18px 48px rgba(220,38,38,.32);background:linear-gradient(180deg, rgba(49,12,16,.96), rgba(24,10,12,.98))}
    .fear-widget.fear-3{border-color:rgba(185,28,28,.7);box-shadow:0 22px 58px rgba(185,28,28,.36);background:linear-gradient(180deg, rgba(58,10,14,.96), rgba(30,8,10,.98))}
    .fear-widget.fear-4{border-color:rgba(239,68,68,.82);box-shadow:0 28px 72px rgba(239,68,68,.45);background:linear-gradient(180deg, rgba(74,10,14,.97), rgba(32,6,8,.99))}

    .progress-stack{display:flex;flex-direction:column;align-items:center;gap:.3rem;pointer-events:none}
    .progress-stack .label{font-size:10px;letter-spacing:.24em;text-transform:uppercase;color:rgba(248,189,189,.85)}
    .progress-bar{width:min(260px,48vw);height:10px;border-radius:999px;background:rgba(22,22,28,.88);border:1px solid rgba(248,113,113,.38);overflow:hidden;position:relative;box-shadow:inset 0 0 14px rgba(0,0,0,.55)}
    .progress-bar>i{position:absolute;inset:0;background:linear-gradient(90deg,#f87171,#ef4444,#991b1b);transform-origin:left center;transform:scaleX(0);transition:transform .3s ease}

    .overlay{position:absolute;inset:0;display:grid;place-items:center;color:#fef2ff;z-index:15}
    .menu{pointer-events:auto;display:flex;flex-direction:column;align-items:center;gap:18px;background:linear-gradient(180deg, rgba(24,24,28,.92), rgba(16,16,22,.96));backdrop-filter:blur(16px);padding:34px;border:1px solid rgba(248,113,113,.38);border-radius:18px;text-align:center;box-shadow:0 24px 64px rgba(0,0,0,.62)}
    .menu.story p{max-width:520px;margin:0;color:rgba(248,202,202,.82)}
    .story-progress{font-size:11px;letter-spacing:.22em;text-transform:uppercase;color:rgba(248,113,113,.62)}
    .title{font:800 48px/1.05 "Cinzel", Trajan, serif;letter-spacing:.08em;text-transform:uppercase;text-align:center;text-shadow:0 0 22px rgba(239,68,68,.75);color:#fef2f2}
    .subtitle{opacity:.92;font-size:15px;letter-spacing:.2em;text-transform:uppercase;color:#fca5a5}
    .warn{font-size:12px;opacity:.85;color:#fca5a5;max-width:640px}
    .flash{animation:flash 1.6s infinite}
    .score-list{display:grid;gap:.45rem;margin-top:12px;width:100%;max-width:360px;max-height:200px;overflow:auto;padding-right:4px}
    .score-item{display:flex;justify-content:space-between;align-items:center;padding:.45rem .75rem;border-radius:12px;background:rgba(14,14,16,.7);border:1px solid rgba(248,113,113,.2);color:#fef2ff;font-size:13px;text-transform:uppercase;letter-spacing:.12em}
    .score-item span:last-child{font-weight:700;letter-spacing:.1em;color:#ffe4f8}
    .score-list-title{margin-top:16px;font-size:12px;letter-spacing:.24em;text-transform:uppercase;color:rgba(248,189,189,.72)}

    .score-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:16px;margin-top:20px;width:100%;max-width:480px}
    .score-card{border:1px solid rgba(248,113,113,.28);background:rgba(16,16,20,.78);color:#fef2ff;font:600 16px/1.2 "Inter", sans-serif;padding:16px;border-radius:14px;display:flex;flex-direction:column;gap:6px;cursor:pointer;transition:transform .15s ease, background .15s ease;appearance:none;text-align:left}
    .score-card span{font-size:12px;color:rgba(248,189,189,.85);font-weight:500;text-transform:uppercase;letter-spacing:.14em}
    .score-card:hover{transform:translateY(-2px);background:rgba(20,20,26,.86)}
    .admin-tools{display:flex;flex-direction:column;gap:10px}
    .menu.hint{gap:14px;padding:26px 28px;max-width:420px}
    .menu.hint p{margin:0;font-size:14px;color:#fef2f2}
    .menu.name{gap:18px;padding:28px 30px;max-width:380px}
    .menu.name input{width:100%;padding:.65rem .85rem;border-radius:12px;border:1px solid rgba(248,113,113,.35);background:rgba(18,18,22,.9);color:#fef2ff;font-size:16px;font-weight:600;letter-spacing:.08em;box-shadow:inset 0 0 14px rgba(0,0,0,.4)}
    .menu.name small{font-size:12px;color:rgba(248,189,189,.78);letter-spacing:.18em;text-transform:uppercase}

    .settings-layer{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(12,12,16,.85);backdrop-filter:blur(20px);z-index:60}
    .settings-layer[hidden]{display:none}
    .settings-panel{width:min(440px,calc(100% - 48px));max-height:calc(100% - 80px);overflow:auto;padding:28px 30px;border-radius:20px;background:linear-gradient(180deg, rgba(34,34,40,.96), rgba(20,20,26,.99));border:1px solid rgba(248,113,113,.48);box-shadow:0 32px 86px rgba(0,0,0,.7);display:flex;flex-direction:column;gap:20px;color:#f9fafb}
    .settings-panel h2{margin:0;font:700 24px/1.1 "Cinzel", Trajan, serif;letter-spacing:.12em;text-transform:uppercase;text-align:center;text-shadow:0 0 18px rgba(248,113,113,.55)}
    .settings-panel p{margin:0;font-size:13px;color:rgba(248,189,189,.82);text-align:center}
    .settings-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(170px,1fr));gap:16px}
    .setting-tile{padding:16px;border-radius:16px;background:linear-gradient(180deg, rgba(38,40,45,.9), rgba(22,24,28,.96));border:1px solid rgba(248,113,113,.28);box-shadow:0 16px 32px rgba(0,0,0,.35);display:flex;justify-content:space-between;align-items:center;gap:14px;font-size:13px}
    .setting-tile label{display:flex;flex-direction:column;gap:6px;font-weight:600;letter-spacing:.1em;text-transform:uppercase;color:#fca5a5;font-size:11px}
    .setting-tile span{font-weight:600;color:#ffffff}
    .setting-tile small{display:block;margin-top:2px;font-size:11px;color:rgba(248,189,189,.7);letter-spacing:.04em;text-transform:none;font-weight:400}
    .settings-panel input[type="text"]{width:100%;padding:.6rem .8rem;border-radius:12px;border:1px solid rgba(248,113,113,.38);background:rgba(20,22,26,.95);color:#ffffff;font-weight:600;letter-spacing:.05em;box-shadow:inset 0 0 14px rgba(0,0,0,.45)}
    .settings-panel input[type="checkbox"], .settings-panel input[type="radio"]{width:20px;height:20px;accent-color:#ef4444}
    .settings-actions{display:flex;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .settings-actions .btn{flex:1;justify-content:center}

    .jumpscare-layer{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at 50% 35%, rgba(255,255,255,.1), rgba(120,0,40,.78) 55%, rgba(0,0,0,.96));z-index:80;pointer-events:none;animation:jumpscareFlash .7s ease}
    .jumpscare-layer.active{background:radial-gradient(circle at 50% 35%, rgba(255,255,255,.16), rgba(190,0,40,.88) 48%, rgba(0,0,0,.96))}
    .jumpscare-face{position:relative;width:min(360px,70vw);height:min(360px,70vw);border-radius:50%;background:radial-gradient(circle at 50% 30%, rgba(255,210,210,.22), rgba(120,0,30,.82));box-shadow:0 0 120px rgba(255,0,90,.45) inset,0 0 80px rgba(255,120,180,.35)}
    .jumpscare-eye{position:absolute;width:32%;height:32%;border-radius:50%;background:radial-gradient(circle, #fff 0%, #f87171 45%, #111 78%);box-shadow:0 0 40px rgba(255,255,255,.45)}
    .jumpscare-eye.left{left:9%;top:28%}
    .jumpscare-eye.right{right:9%;top:28%}
    .jumpscare-eye::after{content:"";position:absolute;width:28%;height:28%;border-radius:50%;background:#fff;top:24%;left:32%;animation:jumpscareBlink .7s ease}
    .jumpscare-mouth{position:absolute;bottom:16%;width:62%;height:36%;border-radius:120px 120px 60px 60px/90px 90px 40px 40px;background:radial-gradient(circle at 50% 10%, #ffedd5 0%, #7f1d1d 55%, #1f0008 90%);box-shadow:0 -10px 40px rgba(255,255,255,.25)}
    .jumpscare-text{position:absolute;bottom:-16%;font:700 clamp(18px,4vw,28px)/1 "Cinzel", serif;letter-spacing:.32em;text-transform:uppercase;color:#fee2e2;text-shadow:0 0 20px rgba(255,0,80,.8)}
    @keyframes jumpscareFlash{0%{opacity:0}15%{opacity:1}100%{opacity:0}}
    @keyframes jumpscareBlink{0%,20%{transform:scaleY(1)}40%{transform:scaleY(0.18)}70%{transform:scaleY(1)}100%{transform:scaleY(1)}}
    body.fear-flash{animation:fearFlash .6s ease}
    @keyframes fearFlash{0%{filter:contrast(160%) saturate(160%)}100%{filter:none}}

    footer{display:flex;justify-content:space-between;align-items:center;padding:.6rem 1.6rem;border-top:1px solid rgba(239,68,68,.28);background:rgba(15,15,17,.92);backdrop-filter:blur(10px);font-size:12px;color:rgba(248,250,252,.7)}
    footer .footer-note{letter-spacing:.12em;text-transform:uppercase}

    @keyframes flash{0%,60%{opacity:.25}70%{opacity:.75}100%{opacity:.25}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Evil Peggle</h1>
      <div class="sp"></div>
      <div class="row">
        <button id="menuBtn" class="btn" title="Open menu">☰ Menu</button>
      </div>
    </header>
    <main>
      <div class="crt">
        <canvas id="game" width="960" height="720"></canvas>
        <div class="hud-layer" id="hudLayer">
          <div class="hud-top">
            <div class="hud-cluster">
              <div class="hud-chip tight">
                <span class="label">Level</span>
                <span class="value" id="levelLabel">1</span>
              </div>
              <div class="hud-chip tight">
                <span class="label">Balls</span>
                <span class="value" id="ballsLabel">10</span>
              </div>
              <div class="hud-chip">
                <span class="label">Score</span>
                <span class="value" id="scoreLabel">0</span>
              </div>
            </div>
            <div class="sp"></div>
            <div class="fear-widget" id="fearWidget" aria-live="polite">
              <span class="label">Fear</span>
              <span class="tier" id="fearStageLabel">Calm</span>
              <div class="fear-bar"><i id="fearFill"></i></div>
              <span class="value" id="fearLabel">0%</span>
            </div>
          </div>
          <div class="hud-bottom">
            <div class="hud-cluster">
              <div class="hud-chip">
                <span class="label">Cursed</span>
                <span class="value" id="cursedLabel">0 / 0</span>
              </div>
              <div class="hud-chip">
                <span class="label">Streak</span>
                <span class="value" id="streakLabel">0</span>
              </div>
            </div>
            <div class="hud-progress">
              <span class="label">Gate To Next</span>
              <div class="progress-bar"><i id="progressFill"></i></div>
            </div>
          </div>
        </div>
        <div class="overlay" id="uiOverlay"></div>
      </div>
    </main>
    <footer>
      <span class="footer-note">Version 1 • Wear headphones</span>
      <span id="playerBadge">Watcher: Wanderer • Left click to fire • ESC for settings</span>
    </footer>
  </div>

  <div class="settings-layer" id="settingsModal" hidden></div>

<script>
(() => {
  // ===== Canvas & UI =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const ui = document.getElementById('uiOverlay');
  ui.style.pointerEvents = 'none';

  // ===== HUD refs =====
  const ballsLabel = document.getElementById('ballsLabel');
  const scoreLabel = document.getElementById('scoreLabel');
  const streakLabel = document.getElementById('streakLabel');
  const cursedLabel = document.getElementById('cursedLabel');
  const levelLabel  = document.getElementById('levelLabel');
  const fearLabel   = document.getElementById('fearLabel');
  const fearFill    = document.getElementById('fearFill');
  const fearWidget  = document.getElementById('fearWidget');
  const fearStageLabel = document.getElementById('fearStageLabel');
  const powerLabel  = document.getElementById('powerLabel');
  const hudLayer = document.getElementById('hudLayer');
  const progressFill= document.getElementById('progressFill');
  const settingsModal = document.getElementById('settingsModal');
  const playerBadge = document.getElementById('playerBadge');
  if(settingsModal){
    settingsModal.addEventListener('click', (e)=>{ if(e.target===settingsModal) closeSettings(); });
  }

  const SETTINGS_KEY = 'evilPeggle.settings.v1';
  const defaultSettings = {
    playerName: 'Wanderer',
    bloodEnabled: true,
    audioEnabled: true,
    fearEffects: true,
    showTutorial: true,
    storySeen: false,
    storyCleared: false,
    storyProgress: 1,
    quality: 'Med',
    stats: { bestScores: {} }
  };
  const QUALITY_OPTIONS = ['Low','Med','High'];

  const POW = { NONE:'none', SKULL:'skull', ROTTEN:'rotten' };
  const FEAR_STAGES = [
    { threshold: 0, label: 'Calm', className: 'fear-0' },
    { threshold: 20, label: 'Uneasy', className: 'fear-1' },
    { threshold: 40, label: 'Dread', className: 'fear-2' },
    { threshold: 60, label: 'Panic', className: 'fear-3' },
    { threshold: 80, label: 'Nightmare', className: 'fear-4' }
  ];
  let currentFearStage = -1;
  const STREAK_MILESTONES = [2,3,5,8,12,18,25];
  let lastStreakPing = 0;
  const POW_DATA = {
    [POW.NONE]:  { short:'—', label:'No Power', color:'#e2e8f0', desc:'Standard eyeball.' },
    [POW.SKULL]: { short:'Skull', label:'Flaming Skull', color:'#fb7185', desc:'Pierces up to three pegs.' },
    [POW.ROTTEN]:{ short:'Rotten', label:'Rotten Orb', color:'#bef264', desc:'Shrinks the bucket until caught.' }
  };

  const MODE = { STORY:'story', FREEPLAY:'freeplay' };
  let gameMode = MODE.STORY;
  let freeplayLevel = 1;

  const settings = loadSettings();
  if(!settings.stats || typeof settings.stats !== 'object') settings.stats = { bestScores:{} };
  if(!settings.stats.bestScores || typeof settings.stats.bestScores !== 'object') settings.stats.bestScores = {};
  if(typeof settings.storyCleared !== 'boolean') settings.storyCleared = false;
  if(typeof settings.adminUnlocked !== 'boolean') settings.adminUnlocked = false;
  if(typeof settings.storyProgress !== 'number' || !Number.isFinite(settings.storyProgress)) settings.storyProgress = 1;
  refreshPlayerBadge();
  setFearStage(getFearStage(0));

  function loadSettings(){
    try{
      const raw = localStorage.getItem(SETTINGS_KEY);
      if(!raw) return { ...defaultSettings };
      const parsed = JSON.parse(raw);
      return { ...defaultSettings, ...parsed };
    } catch(err){
      console.warn('Failed to load settings', err);
      return { ...defaultSettings };
    }
  }

  function persistSettings(){
    try{ localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }
    catch(err){ console.warn('Failed to store settings', err); }
  }

  function escHTML(str){
    const map = {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};
    return String(str ?? '').replace(/[&<>'"]/g, m => map[m]);
  }

  function refreshPlayerBadge(){
    if(!playerBadge) return;
    const name = (settings.playerName || '').trim() || 'Wanderer';
    playerBadge.textContent = `Player: ${name} • Left click to fire • ESC for settings`;
  }

  function stopGame(){
    world.ball = null;
    world.aim.ready = false;
    world.bucket.open = true;
    world.bucket.anim = 0;
    syncHUDVisibility();
  }

  function getBestScore(level){
    return settings.stats.bestScores[String(level)] ?? null;
  }

  function formatScore(val){
    if(val==null) return '—';
    return Number(val).toLocaleString();
  }

  function recordBest(level, score){
    if(score==null || isNaN(score)) return;
    const key = String(level);
    const current = settings.stats.bestScores[key] ?? 0;
    if(score > current){
      settings.stats.bestScores[key] = score;
      persistSettings();
    }
  }

  function buildSettingsMarkup(){
    const nameVal = escHTML(settings.playerName || '');
    const qualityOpts = QUALITY_OPTIONS.map(opt => `<option ${opt===settings.quality? 'selected':''}>${opt}</option>`).join('');
    const adminSection = settings.adminUnlocked ? `
      <div class="setting-tile" style="flex-direction:column;align-items:stretch;gap:10px">
        <label><span>Admin Tools</span><small>Testing utilities — keep secret.</small></label>
        <div class="admin-tools">
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <button class="btn" id="adminAddScore">+1k Score</button>
            <button class="btn" id="adminUnlockStory">Unlock Freeplay</button>
            <button class="btn" id="adminClearScores">Clear Best Scores</button>
          </div>
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <label style="letter-spacing:.08em;text-transform:uppercase;font-size:11px;color:rgba(248,189,189,.85)">Warp Level</label>
            <input type="number" id="adminLevelInput" min="1" max="${TOTAL_LEVELS}" value="${Math.min(TOTAL_LEVELS, Math.max(1, world.level))}" style="width:70px" />
            <button class="btn" id="adminWarp">Go</button>
          </div>
          <button class="btn" id="adminDisable">Disable Admin Mode</button>
        </div>
      </div>` : '';
    return `
      <div class="settings-panel">
        <h2>Ritual Settings</h2>
        <p>Personalise the encore torment. Changes save immediately.</p>
        <div class="setting-tile">
          <div>
            <span>Player Sigil</span>
            <small>Used in whispers and the story interludes.</small>
          </div>
          <input type="text" id="playerNameInput" maxlength="16" value="${nameVal}" />
        </div>
        <div class="settings-grid">
          <div class="setting-tile">
            <label>
              <span>Blood &amp; Gore</span>
              <small>Disable splatters if you need a breather.</small>
            </label>
            <input type="checkbox" id="bloodToggle" ${settings.bloodEnabled? 'checked':''}>
          </div>
          <div class="setting-tile">
            <label>
              <span>Fear Events</span>
              <small>Hallucinations, glitches, and jumpscares.</small>
            </label>
            <input type="checkbox" id="fearToggle" ${settings.fearEffects!==false? 'checked':''}>
          </div>
          <div class="setting-tile">
            <label>
              <span>Ambient Audio</span>
              <small>Music, whispers, and impact stingers.</small>
            </label>
            <input type="checkbox" id="audioToggle" ${audioEnabled? 'checked':''}>
          </div>
          <div class="setting-tile">
            <label>
              <span>Guided Tutorial</span>
              <small>Show hints during the first haunt.</small>
            </label>
            <input type="checkbox" id="tutorialToggle" ${settings.showTutorial? 'checked':''}>
          </div>
        </div>
        <div class="setting-tile">
          <label>
            <span>Visual Quality</span>
            <small>Affects particle count and lighting.</small>
          </label>
          <select id="qualitySelectModal">${qualityOpts}</select>
        </div>
        <div class="settings-actions">
          <button class="btn" id="modalHomeBtn">⌂ Menu</button>
          <button class="btn danger" id="modalResetBtn">⟲ Reset Level</button>
          <button class="btn" id="modalCloseBtn">✖ Close</button>
          <button class="btn good" id="modalResumeBtn">✔ Resume</button>
        </div>
        <button class="btn" id="modalGuideBtn" style="align-self:center">ℹ How to Play</button>
        <button class="btn" id="modalForgetBtn" style="align-self:center">🗙 Forget Profile</button>
        ${adminSection}
      </div>`;
  }

  function wireSettingsModal(){
    const modal = settingsModal;
    const nameInput = modal.querySelector('#playerNameInput');
    const bloodToggle = modal.querySelector('#bloodToggle');
    const fearToggle = modal.querySelector('#fearToggle');
    const audioToggle = modal.querySelector('#audioToggle');
    const tutorialToggle = modal.querySelector('#tutorialToggle');
    const qualityModal = modal.querySelector('#qualitySelectModal');
    const homeButton = modal.querySelector('#modalHomeBtn');
    const resetButton = modal.querySelector('#modalResetBtn');
    const closeButton = modal.querySelector('#modalCloseBtn');
    const resumeButton = modal.querySelector('#modalResumeBtn');
    const storyButton = modal.querySelector('#modalGuideBtn');
    const forgetButton = modal.querySelector('#modalForgetBtn');
    const adminAdd = modal.querySelector('#adminAddScore');
    const adminUnlock = modal.querySelector('#adminUnlockStory');
    const adminClear = modal.querySelector('#adminClearScores');
    const adminWarp = modal.querySelector('#adminWarp');
    const adminLevelInput = modal.querySelector('#adminLevelInput');
    const adminDisable = modal.querySelector('#adminDisable');

    const sanitizeName = val => val.replace(/[^a-z0-9 _!\-]/gi, '').slice(0, 16);

    if(nameInput){
      nameInput.addEventListener('input', e => {
        settings.playerName = sanitizeName(e.target.value);
        e.target.value = settings.playerName;
        persistSettings();
        refreshPlayerBadge();
      });
    }
    if(bloodToggle){
      bloodToggle.addEventListener('change', e => {
        settings.bloodEnabled = e.target.checked;
        persistSettings();
        if(!settings.bloodEnabled) clearBlood();
      });
    }
    if(fearToggle){
      fearToggle.addEventListener('change', e => {
        settings.fearEffects = e.target.checked;
        persistSettings();
      });
    }
    if(audioToggle){
      audioToggle.addEventListener('change', e => {
        setAudio(e.target.checked, false);
      });
    }
    if(tutorialToggle){
      tutorialToggle.addEventListener('change', e => {
        settings.showTutorial = e.target.checked;
        if(e.target.checked) tutorialShown = false;
        persistSettings();
      });
    }
    if(qualityModal){
      qualitySel = qualityModal;
      qualityModal.value = settings.quality;
      qualityModal.addEventListener('change', () => {
        qualitySel = qualityModal;
        applyQuality();
      });
    }
    if(homeButton){
    homeButton.addEventListener('click', () => {
        closeSettings();
        startMenu();
      });
    }
    if(resetButton){
      resetButton.addEventListener('click', () => {
        doResetLevel();
      });
    }
    if(closeButton){ closeButton.addEventListener('click', closeSettings); }
    if(resumeButton){ resumeButton.addEventListener('click', closeSettings); }
    if(storyButton){
      storyButton.addEventListener('click', () => {
        const resumeState = state;
        closeSettings();
        const restore = () => {
          if(resumeState === STATE.PLAY){ state = STATE.PLAY; setOverlay(''); }
          else { startMenu(); }
        };
        showStoryIntro({ markSeen:false, onComplete:restore });
      });
    }
    if(forgetButton){
      forgetButton.addEventListener('click', () => {
        localStorage.removeItem(SETTINGS_KEY);
        Object.assign(settings, { ...defaultSettings });
        qualitySel.value = settings.quality;
        applyQuality();
        setAudio(settings.audioEnabled, false);
        persistSettings();
        refreshPlayerBadge();
        renderSettingsModal();
      });
    }
    if(adminAdd){
      adminAdd.addEventListener('click', () => {
        world.score += 1000;
        updateHUD();
      });
    }
    if(adminUnlock){
      adminUnlock.addEventListener('click', () => {
        settings.storyCleared = true;
        persistSettings();
        closeSettings();
        startMenu();
      });
    }
    if(adminClear){
      adminClear.addEventListener('click', () => {
        settings.stats.bestScores = {};
        persistSettings();
        renderSettingsModal();
      });
    }
    if(adminWarp){
      adminWarp.addEventListener('click', () => {
        const target = parseInt(adminLevelInput?.value||'1', 10);
        if(Number.isFinite(target) && target>=1 && target<=TOTAL_LEVELS){
          closeSettings();
          if(state !== STATE.PLAY){ startGame(); }
          world.score = 0;
          loadLevel(target);
          updateHUD();
          world.aim.ready = true;
        }
      });
    }
    if(adminDisable){
      adminDisable.addEventListener('click', () => {
        settings.adminUnlocked = false;
        persistSettings();
        showFloat('Admin tools disabled', W/2, H/2, { color:'#f87171', glow:'#dc2626', duration:90, rise:0, scale:1.1 });
        renderSettingsModal();
      });
    }
  }

  function renderSettingsModal(){
    settingsModal.innerHTML = buildSettingsMarkup();
    wireSettingsModal();
  }

  function openSettings(){
    if(settingsOpen) return;
    settingsOpen = true;
    stateBeforePause = state;
    if(state === STATE.PLAY){
      state = STATE.PAUSE;
    }
    settingsModal.hidden = false;
    renderSettingsModal();
    syncHUDVisibility();
  }

  function closeSettings(){
    if(!settingsOpen) return;
    settingsModal.hidden = true;
    settingsModal.innerHTML = '';
    settingsOpen = false;
    const previous = stateBeforePause;
    state = previous;
    syncHUDVisibility();
  }

  function doResetLevel(){
    if(state === STATE.PLAY || state === STATE.PAUSE){
      loadLevel(world.level);
      updateHUD();
      stateBeforePause = STATE.PLAY;
      closeSettings();
    } else if(state === STATE.GAMEOVER){
      world.score = 0;
      world.level = 1;
      loadLevel(1);
      updateHUD();
      stateBeforePause = STATE.PLAY;
      closeSettings();
    } else if(state === STATE.MENU){
      stateBeforePause = STATE.PLAY;
      closeSettings();
      startGame();
    } else {
      closeSettings();
    }
  }

  // ===== Controls =====
  const muteBtn = document.getElementById('muteBtn');
  const menuBtn = document.getElementById('menuBtn');
  let qualitySel = null;
  if(menuBtn){ menuBtn.onclick = () => openSettings(); }

  // ===== Quality toggle =====
  const quality = { mul: 1 };
  function applyQuality(){
    const q = qualitySel?.value || settings.quality || 'Med';
    quality.mul = q==='Low'? 0.6 : q==='High'? 2.0 : 1.0;
    settings.quality = q;
    persistSettings();
  }
  applyQuality();

  // ===== Audio (procedural) =====
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let ac; let audioEnabled = settings.audioEnabled !== false;
  function ensureAudio(){ if(!ac){ ac = new AudioCtx(); startMusic(); }}
  function tone(freq=200, dur=0.06, type='square', gain=0.02){ if(!audioEnabled) return; ensureAudio(); const o=ac.createOscillator(); const g=ac.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=gain; o.connect(g); g.connect(ac.destination); o.start(); o.stop(ac.currentTime+dur); }
  function noise(ms=100, vol=.12){ if(!audioEnabled) return; ensureAudio(); const n=ac.createBuffer(1, ac.sampleRate*ms/1000, ac.sampleRate); const d=n.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*(1-i/d.length); const s=ac.createBufferSource(); s.buffer=n; const g=ac.createGain(); g.gain.value=vol; s.connect(g); g.connect(ac.destination); s.start(); }
  function sting(){ if(!audioEnabled) return; ensureAudio(); const g=ac.createGain(); g.gain.value=.05; g.connect(ac.destination); [110, 147, 196, 277].forEach((f,i)=>{ const o=ac.createOscillator(); o.type='sawtooth'; o.frequency.value=f; o.connect(g); o.start(); o.stop(ac.currentTime+0.5+i*0.02)}); }
  function subBoom(){ if(!audioEnabled) return; ensureAudio(); const o=ac.createOscillator(); const g=ac.createGain(); o.type='sine'; o.frequency.setValueAtTime(160, ac.currentTime); o.frequency.exponentialRampToValueAtTime(40, ac.currentTime+0.6); g.gain.value=.06; o.connect(g); g.connect(ac.destination); o.start(); o.stop(ac.currentTime+0.65); }

  // Dissonant loop (detuned organ)
  let musicNode; function startMusic(){ if(!audioEnabled) return; if(musicNode){ try{musicNode.stop();}catch{}} ensureAudio(); const g=ac.createGain(); g.gain.value=.03; g.connect(ac.destination); const freqs=[196, 247, 330]; const detunes=[-8, 0, +7]; const oscs=[]; for(let i=0;i<freqs.length;i++){ const o=ac.createOscillator(); o.type='triangle'; o.frequency.value=freqs[i]; o.detune.value=detunes[i]; o.connect(g); o.start(); oscs.push(o);} // slow filter wobble
    setInterval(()=>{ if(!ac) return; g.gain.value = .02 + Math.random()*0.015; }, 1200);
    musicNode = { stop(){ oscs.forEach(o=>o.stop()); } };
  }

  // Whispers (procedural hiss + formant-ish tone)
  function whisper(){ if(!audioEnabled) return; ensureAudio(); const dur=0.9; const n=ac.createBuffer(1, ac.sampleRate*dur, ac.sampleRate); const d=n.getChannelData(0); for(let i=0;i<d.length;i++){ const t=i/d.length; d[i]=(Math.random()*2-1)*0.4*(1-t); } const s=ac.createBufferSource(); s.buffer=n; const g=ac.createGain(); g.gain.value=.03; s.connect(g); g.connect(ac.destination); s.start(); }

  function syncAudioButton(){ if(muteBtn) muteBtn.textContent = audioEnabled? '🔊 Audio':'🔇 Muted'; }

  function setAudio(flag, chime=true){
    const next = !!flag;
    audioEnabled = next;
    settings.audioEnabled = next;
    persistSettings();
    syncAudioButton();
    if(!next && musicNode){ try{ musicNode.stop(); } catch{} musicNode = null; }
    if(next && chime){ ensureAudio(); tone(720,0.06,'sine',0.03); }
  }

  syncAudioButton();

  if(muteBtn){ muteBtn.onclick = () => { setAudio(!audioEnabled); }; }

  // ===== Sprites (embedded SVG -> Image) =====
  const Spr = {};
  function svgToImg(svg){ const img=new Image(); img.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(svg.trim()); return img; }
  // Eyeball ball sprite (normal)
  Spr.ball = svgToImg(`
  <svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'>
    <defs>
      <radialGradient id='g1' cx='50%' cy='50%' r='50%'>
        <stop offset='0%' stop-color='#fff'/>
        <stop offset='100%' stop-color='#ddd'/>
      </radialGradient>
    </defs>
    <circle cx='32' cy='32' r='30' fill='url(#g1)' stroke='#c9c9c9' stroke-width='2'/>
    <circle cx='32' cy='32' r='18' fill='#8b1226'/>
    <circle cx='30' cy='31' r='9' fill='#050508'/>
    <circle cx='28' cy='29' r='3' fill='#9e9eff' opacity='.5'/>
    <path d='M6 20 C14 18, 20 14, 26 12' stroke='#e33' stroke-width='2' fill='none' opacity='.6'/>
    <path d='M8 40 C18 42, 14 50, 22 54' stroke='#e33' stroke-width='2' fill='none' opacity='.6'/>
    <path d='M58 22 C46 16, 40 14, 34 12' stroke='#e33' stroke-width='2' fill='none' opacity='.6'/>
  </svg>`);
  // Flaming skull ball
  Spr.skull = svgToImg(`
  <svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'>
    <defs><radialGradient id='f' cx='50%' cy='50%' r='50%'>
      <stop offset='0%' stop-color='#fff7d6'/>
      <stop offset='60%' stop-color='#ffb84a'/>
      <stop offset='100%' stop-color='#a31616'/>
    </radialGradient></defs>
    <circle cx='32' cy='32' r='28' fill='url(#f)'/>
    <path d='M16 34 Q32 12 48 34' fill='#eee' stroke='#333' stroke-width='2'/>
    <circle cx='26' cy='32' r='6' fill='#111'/>
    <circle cx='38' cy='32' r='6' fill='#111'/>
    <rect x='26' y='40' width='12' height='6' rx='2' fill='#111'/>
    <path d='M12 28 C20 14, 28 10, 32 8 C36 10, 44 14, 52 28' fill='none' stroke='#ff6' stroke-width='3'/>
  </svg>`);
  // Rotten eyeball ball
  Spr.rotten = svgToImg(`
  <svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'>
    <defs><radialGradient id='r' cx='50%' cy='50%' r='50%'>
      <stop offset='0%' stop-color='#e2ffd5'/>
      <stop offset='100%' stop-color='#a5d08b'/>
    </radialGradient></defs>
    <circle cx='32' cy='32' r='30' fill='url(#r)' stroke='#6b8f54' stroke-width='2'/>
    <circle cx='32' cy='32' r='16' fill='#396b2c'/>
    <circle cx='31' cy='31' r='7' fill='#071a05'/>
  </svg>`);
  // Cursed face peg (two frames: open/closed mouth)
  Spr.cursedA = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'><defs><radialGradient id='r' cx='50%' cy='40%' r='60%'><stop offset='0%' stop-color='#ff647c'/><stop offset='60%' stop-color='#d2122e'/><stop offset='100%' stop-color='#6b0814'/></radialGradient></defs><circle cx='24' cy='24' r='22' fill='url(#r)' stroke='#2b0007' stroke-width='2'/><ellipse cx='16' cy='20' rx='6' ry='5' fill='#1a0010'/><ellipse cx='32' cy='20' rx='6' ry='5' fill='#1a0010'/><path d='M12 30 Q24 38 36 30' stroke='#1a0010' stroke-width='4' fill='none'/></svg>`);
  Spr.cursedB = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'><defs><radialGradient id='r' cx='50%' cy='40%' r='60%'><stop offset='0%' stop-color='#ff647c'/><stop offset='60%' stop-color='#d2122e'/><stop offset='100%' stop-color='#6b0814'/></radialGradient></defs><circle cx='24' cy='24' r='22' fill='url(#r)' stroke='#2b0007' stroke-width='2'/><ellipse cx='16' cy='20' rx='6' ry='5' fill='#1a0010'/><ellipse cx='32' cy='20' rx='6' ry='5' fill='#1a0010'/><path d='M12 30 Q24 28 36 30' stroke='#1a0010' stroke-width='5' fill='none'/></svg>`);
  // Normal meat peg
  Spr.meat = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='44' height='44' viewBox='0 0 44 44'><defs><radialGradient id='m' cx='50%' cy='45%' r='65%'><stop offset='0%' stop-color='#ffb3c2'/><stop offset='70%' stop-color='#a11428'/><stop offset='100%' stop-color='#47020a'/></radialGradient></defs><circle cx='22' cy='22' r='20' fill='url(#m)' stroke='#36010a' stroke-width='2'/><path d='M8 18 Q22 12 36 18' stroke='#5b0210' stroke-width='2' fill='none' opacity='.6'/></svg>`);
  // Steel peg
  Spr.steel = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='44' height='44' viewBox='0 0 44 44'><defs><radialGradient id='s' cx='35%' cy='35%' r='70%'><stop offset='0%' stop-color='#fafafa'/><stop offset='70%' stop-color='#8f949c'/><stop offset='100%' stop-color='#3c4046'/></radialGradient></defs><circle cx='22' cy='22' r='19' fill='url(#s)' stroke='#24262a' stroke-width='2'/><circle cx='22' cy='22' r='5' fill='#1a1c1f'/></svg>`);
  // Blood splat sprite
  Spr.splat = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'><g fill='#6f0011'><path d='M32 10c-8 0-13 6-13 11s4 9 13 9 16-4 16-9-8-11-16-11z'/><circle cx='12' cy='20' r='5'/><circle cx='20' cy='44' r='6'/><circle cx='48' cy='36' r='7'/><circle cx='40' cy='54' r='4'/></g></svg>`);
  // Background wallpaper
  Spr.bg = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='960' height='640' viewBox='0 0 960 640'>
    <defs>
      <linearGradient id='bgFloor' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#18191f'/>
        <stop offset='60%' stop-color='#0f1016'/>
        <stop offset='100%' stop-color='#06070a'/>
      </linearGradient>
      <radialGradient id='spot' cx='50%' cy='0%' r='80%'>
        <stop offset='0%' stop-color='rgba(239,68,68,.42)'/>
        <stop offset='35%' stop-color='rgba(190,24,24,.2)'/>
        <stop offset='100%' stop-color='rgba(0,0,0,0)'/>
      </radialGradient>
      <linearGradient id='bandA' x1='0' y1='0' x2='1' y2='0'>
        <stop offset='0%' stop-color='rgba(239,68,68,.8)'/>
        <stop offset='100%' stop-color='rgba(239,68,68,0)'/>
      </linearGradient>
      <linearGradient id='bandB' x1='1' y1='0' x2='0' y2='0'>
        <stop offset='0%' stop-color='rgba(127,29,29,.8)'/>
        <stop offset='100%' stop-color='rgba(127,29,29,0)'/>
      </linearGradient>
    </defs>
    <rect width='960' height='640' fill='url(#bgFloor)'/>
    <rect width='960' height='320' fill='url(#spot)'/>
    <g opacity='.22'>
      <path d='M-60 520 C160 440, 320 560, 540 520 S 940 560, 1020 500' stroke='rgba(239,68,68,.42)' stroke-width='90' fill='none' stroke-linecap='round'/>
      <path d='M-40 440 C140 500, 360 420, 620 460 S 940 420, 1080 460' stroke='rgba(82,82,94,.4)' stroke-width='36' fill='none' stroke-linecap='round' stroke-dasharray='46 26'/>
    </g>
    <g opacity='.28'>
      <rect x='0' y='0' width='160' height='640' fill='url(#bandA)'/>
      <rect x='800' y='0' width='160' height='640' fill='url(#bandB)'/>
    </g>
  </svg>`);
  // Bucket monster (open/closed)
  Spr.bucketOpen = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='140' height='40' viewBox='0 0 140 40'><rect x='0' y='6' width='140' height='28' rx='6' fill='#1a1c22' stroke='#2c3038' stroke-width='3'/><g fill='#e7e7e7' stroke='#111' stroke-width='1'><polygon points='10,6 20,22 0,22'/><polygon points='30,6 40,22 20,22'/><polygon points='50,6 60,22 40,22'/><polygon points='70,6 80,22 60,22'/><polygon points='90,6 100,22 80,22'/><polygon points='110,6 120,22 100,22'/><polygon points='130,6 140,22 120,22'/></g></svg>`);
  Spr.bucketClosed = svgToImg(`<svg xmlns='http://www.w3.org/2000/svg' width='140' height='40' viewBox='0 0 140 40'><rect x='0' y='10' width='140' height='24' rx='6' fill='#1a1c22' stroke='#2c3038' stroke-width='3'/><g fill='#e7e7e7' stroke='#111' stroke-width='1'><polygon points='10,34 20,20 0,20'/><polygon points='30,34 40,20 20,20'/><polygon points='50,34 60,20 40,20'/><polygon points='70,34 80,20 60,20'/><polygon points='90,34 100,20 80,20'/><polygon points='110,34 120,20 100,20'/><polygon points='130,34 140,20 120,20'/></g></svg>`);

  // ===== Game State =====
  const STATE = { BOOT:0, MENU:1, PLAY:2, GAMEOVER:3, PAUSE:4 };
  let state = STATE.BOOT;
  let bootProg=0;
  let bootMsgIdx=0;
  let settingsOpen = false;
  let stateBeforePause = STATE.PLAY;
  let tutorialShown = false;
  let jumpscareCooldown = 0;
  let jumpscareActive = false;
  function syncHUDVisibility(){ if(!hudLayer) return; hudLayer.style.opacity = state===STATE.PLAY?1:0; }
  syncHUDVisibility();
  const bootMsgs = [
    "Sound-checking the void…",
    "Tuning haunted strings…",
    "Feeding amps with blood…",
    "Rehearsing the screams…",
    "Dropping the crimson curtain…"
  ];
  const MENU_HINTS = [
    "Catch the bucket beast to earn another shot.",
    "Steel pegs just bounce — bring powers to break the rhythm.",
    "Fear climbs faster with streaks. High fear changes everything.",
    "Flaming Skull pierces three pegs. Rotten orbs shrink the bucket.",
    "Press ESC anytime for settings, blood toggle, or a reset."
  ];
  const TUTORIAL_STEPS = [
    { title: 'Aim & Fire', body: 'Move the mouse to aim from the top center. Left click to launch the haunted eyeball.' },
    { title: 'Clear The Reds', body: 'Break every cursed red peg before you run out of shots to open the gate to the next stage.' },
    { title: 'Catch The Bucket', body: 'Drop into the bucket beast to recover a ball and boost your streak.' },
    { title: 'Fear Meter', body: 'Streaks and cursed hits fill the Fear bar. High fear twists the arena and unlocks stronger effects.' }
  ];

  function renderScoreList(){
    let html = '<div class="score-list">';
    for(let i=1;i<=TOTAL_LEVELS;i++){
      html += `<div class="score-item"><span>Level ${i}</span><span>${formatScore(getBestScore(i))}</span></div>`;
    }
    html += '</div>';
    return html;
  }

  const world = {
    gravity: 0.34,
    friction: 0.995,
    ballsLeft: 10,
    score: 0,
    streak: 0,
    level: 1,
    ball: null,
    ballType: POW.NONE,
    pierce: 0,
    pegs: [],
    hallucinations: [],
    decals: [],
    particles: [],
    bucket: { x: W*0.25, y: H-30, w: 140, h: 34, vx: 2.2, open: true, anim:0 },
    aim: { x: W/2, y: 60, ang: -Math.PI/2, power: 14, ready: false },
    clearedCursed: 0,
    totalCursed: 0,
    screenShake: 0,
    fear: 0,
    levelBaselineScore: 0,
  };

  // ===== Level helpers =====
  function makeGrid(rows, cols, offsetY=140, jitter=10, curseEvery=5){
    const arr=[]; const gapX=W/(cols+1), gapY=52;
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
      const x = gapX*(c+1) + (Math.random()*2-1)*jitter + (r%2?gapX/2:0);
      const y = offsetY + r*gapY + (Math.random()*2-1)*jitter;
      const cursed = ((r*cols+c)%curseEvery===0);
      arr.push({x,y,r:20,type: cursed? 'cursed':'normal', hit:false, t:Math.random()*100});
    }
    return arr;
  }
  function ring(cx,cy,rad,count,type='normal'){ const arr=[]; for(let i=0;i<count;i++){ const a=i/count*Math.PI*2; arr.push({x:cx+Math.cos(a)*rad,y:cy+Math.sin(a)*rad,r:20,type,hit:false,t:Math.random()*100}); } return arr; }
  function spiral(cx, cy, turns=10, step=22, count=90){ const arr=[]; let t=0; for(let i=0;i<count;i++){ const r= t*step; const a = t * 0.55; arr.push({x:cx+Math.cos(a)*r, y:cy+Math.sin(a)*r, r:18, type: (i%7===0? 'cursed':'normal'), hit:false,t:Math.random()*100}); t += turns/count; } return arr; }
  function mix(arr, nSteel=10){ for(let i=0;i<nSteel && i<arr.length;i++) arr[i].type='steel'; return arr; }
  const peg = (x,y,type='normal',r=20)=>({x,y,r,type,hit:false,t:Math.random()*100});
  function columnsLayout(colCount=6,rowCount=6,offsetY=130,shift=20,curseStride=3){
    const arr=[]; const gapX=W/(colCount+1); const gapY=52;
    for(let c=0;c<colCount;c++){
      for(let r=0;r<rowCount;r++){
        const x = gapX*(c+1);
        const y = offsetY + r*gapY + (c%2?shift:-shift);
        const cursed = ((r + c)%curseStride===0);
        arr.push(peg(x,y,cursed?'cursed':'normal'));
      }
    }
    return arr;
  }
  function waveLayout(rows=5, cols=10, offsetY=120, amplitude=36, freq=0.6){
    const arr=[]; const gapX=W/(cols+1); const gapY=52;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = gapX*(c+1);
        const baseY = offsetY + r*gapY;
        const y = baseY + Math.sin((c+ r*0.4)*freq)*amplitude;
        const cursed = ((c+r)%4===0);
        arr.push(peg(x,y,cursed?'cursed':'normal'));
      }
    }
    return arr;
  }
  function targetLayout(cx, cy){
    return [
      ...ring(cx, cy, 60, 8),
      ...ring(cx, cy, 100, 12, 'cursed'),
      ...ring(cx, cy, 140, 16),
      ...ring(cx, cy, 180, 20, 'cursed')
    ];
  }
  function scatterLayout(count=48, cursedRatio=0.26, top=120, bottom=H-140){
    const arr=[];
    for(let i=0;i<count;i++){
      const type = (Math.random()<cursedRatio)? 'cursed':'normal';
      const x = 70 + Math.random()*(W-140);
      const y = top + Math.random()*(bottom-top);
      arr.push(peg(x,y,type));
    }
    return arr;
  }
  function doubleSpiral(){
    const a = spiral(W*0.25, H*0.45, 10, 14, 70).map(p=>({ ...p, type: (Math.random()<0.25)?'cursed':p.type }));
    const b = spiral(W*0.75, H*0.45, 10, 14, 70).map(p=>({ ...p, type: (Math.random()<0.25)?'cursed':p.type }));
    return a.concat(b);
  }

  function introSanctum(){
    const arr=[];
    arr.push(...makeGrid(4,7,200,6,5));
    const cy = 360;
    arr.push(...ring(W/2, cy, 100, 6, 'cursed'));
    arr.push(...ring(W/2, cy, 160, 10));
    arr.push(peg(W/2, cy, 'cursed'));
    arr.push(peg(W/2-180, cy+140, 'normal'));
    arr.push(peg(W/2+180, cy+140, 'normal'));
    return arr;
  }

  function crescentGates(){
    const arr=[];
    for(let i=0;i<7;i++){
      const x = 140 + i*110;
      const y = 230 + Math.sin(i*0.55)*40;
      arr.push(peg(x,y, i%3===0?'cursed':'normal'));
    }
    for(let i=0;i<6;i++){
      const x = 180 + i*120;
      const y = 350 + Math.cos(i*0.6)*46;
      arr.push(peg(x,y, i%2===0?'cursed':'normal'));
    }
    arr.push(...ring(W/2, 520, 120, 8, 'cursed'));
    arr.push(...ring(W/2, 520, 180, 14));
    return arr;
  }

  function ritualStar(){
    const arr=[];
    const cy = 360;
    arr.push(peg(W/2, cy, 'cursed'));
    for(let i=0;i<6;i++){
      const a = i/6*Math.PI*2;
      const inner = 110;
      const outer = 190;
      arr.push(peg(W/2 + Math.cos(a)*inner, cy + Math.sin(a)*inner, 'cursed'));
      arr.push(peg(W/2 + Math.cos(a+Math.PI/6)*outer, cy + Math.sin(a+Math.PI/6)*outer, i%2===0?'normal':'steel'));
    }
    for(let i=0;i<4;i++){
      const y = 240 + i*62;
      arr.push(peg(W/2-220, y, i%2===0?'cursed':'normal'));
      arr.push(peg(W/2+220, y+28, i%2===1?'cursed':'normal'));
    }
    arr.push(...ring(W/2, cy+150, 160, 12));
    return arr;
  }

  function whisperSpiral(){
    const arr = spiral(W/2, H*0.5, 12, 20, 96);
    arr.forEach((p,i)=>{
      if(i%6===0) p.type='cursed';
      if(i%13===0) p.type='steel';
    });
    arr.push(...ring(W/2, H*0.5, 220, 16, 'cursed'));
    return arr;
  }

  function terracedColumns(){
    const arr=[];
    arr.push(...columnsLayout(6,6,210,26,4));
    for(let i=0;i<5;i++){
      const y = 240 + i*60;
      arr.push(peg(160, y, i%2===0?'cursed':'normal'));
      arr.push(peg(W-160, y+30, i%2===1?'cursed':'normal'));
    }
    arr.push(...ring(W/2, 540, 150, 12));
    return arr;
  }

  function tidalRun(){
    const arr=[];
    arr.push(...waveLayout(5,9,220,48,0.65));
    for(let i=0;i<6;i++){
      const y = 230 + i*60;
      arr.push(peg(140, y, i%2===0?'cursed':'steel'));
      arr.push(peg(W-140, y+30, i%2===1?'cursed':'steel'));
    }
    arr.push(...ring(W/2, 560, 120, 10, 'cursed'));
    return arr;
  }

  function guardianEye(){
    const arr = [...targetLayout(W/2, 320)];
    arr.push(...ring(W/2, 320, 200, 14, 'steel'));
    for(let i=0;i<6;i++){
      const x = 150 + i*120;
      arr.push(peg(x, 200 + Math.sin(i*0.5)*30, i%3===0?'cursed':'normal'));
    }
    return arr;
  }

  function fractureField(){
    const arr = scatterLayout(42, 0.26, 220, H-200);
    for(let i=0;i<6;i++){
      arr.push(peg(160 + i*110, 260 + i*40, i%2===0?'cursed':'steel'));
      arr.push(peg(W-160 - i*110, 260 + i*40, i%3===0?'steel':'normal'));
    }
    return arr;
  }

  function twinSpirals(){
    const left = spiral(W*0.28, H*0.45, 6.5, 18, 42);
    const right = spiral(W*0.72, H*0.45, 6.5, 18, 42);
    left.forEach((p,i)=>{ if(i%5===0) p.type='cursed'; });
    right.forEach((p,i)=>{ if(i%5===0) p.type='cursed'; if(i%11===0) p.type='steel'; });
    return [...left, ...right, ...ring(W/2, 560, 140, 12, 'cursed')];
  }

  function bulwarkHall(){
    const arr=[];
    arr.push(...columnsLayout(5,7,200,32,3));
    for(let i=0;i<6;i++){
      const x = 140 + i*120;
      arr.push(peg(x, 180, i%2===0?'cursed':'normal'));
      arr.push(peg(x, 520, i%3===0?'steel':'normal'));
    }
    arr.push(...ring(W/2, 360, 180, 14, 'steel'));
    return arr;
  }

  function emberBloom(){
    const arr=[];
    const cy = 340;
    arr.push(...ring(W/2, cy, 80, 6, 'cursed'));
    arr.push(...ring(W/2, cy, 140, 10));
    const outer = ring(W/2, cy, 210, 14);
    outer.forEach((p,i)=>{
      if(i%3===0) p.type='cursed';
      if(i%5===0) p.type='steel';
    });
    arr.push(...outer);
    for(let i=0;i<6;i++){
      const a = -Math.PI/2 + i*(Math.PI*2/6);
      arr.push(peg(W/2 + Math.cos(a)*250, cy + Math.sin(a)*120, i%2===0?'steel':'normal'));
    }
    return arr;
  }

  function glassGarden(){
    const arr=[];
    arr.push(...waveLayout(4,8,200,40,0.5));
    for(let i=0;i<5;i++){
      const x = 180 + i*160;
      arr.push(peg(x, 260, i%2===0?'cursed':'normal'));
      arr.push(peg(x, 420, i%3===0?'steel':'normal'));
    }
    const petals = ring(W/2, 560, 150, 12);
    petals.forEach((p,i)=>{ if(i%4===0) p.type='cursed'; });
    arr.push(...petals);
    return arr;
  }

  function obsidianCrown(){
    const arr = [...targetLayout(W/2, 280)];
    const guard = ring(W/2, 280, 220, 16, 'cursed');
    arr.push(...guard);
    for(let i=0;i<6;i++){
      arr.push(peg(160 + i*120, 520, i%2===0?'steel':'cursed'));
    }
    return arr;
  }

  function leviathanRise(){
    const arr=[];
    for(let r=0;r<6;r++){
      const count = 6 + Math.max(0, r-1);
      const y = 220 + r*60;
      const startX = W/2 - (count-1)*60;
      for(let c=0;c<count;c++){
        const x = startX + c*120;
        const edge = (c===0 || c===count-1);
        const type = edge || (r%2===0 && c%2===0) ? 'cursed' : 'normal';
        arr.push(peg(x,y,type));
      }
    }
    arr.push(...ring(W/2, 560, 130, 12, 'cursed'));
    return arr;
  }

  function voidChorus(){
    const arr=[];
    for(let i=0;i<8;i++){
      const x = 140 + i*100;
      arr.push(peg(x, 200 + Math.sin(i*0.4)*50, i%3===0?'cursed':'normal'));
      arr.push(peg(x, 360 + Math.cos(i*0.5)*40, i%4===0?'steel':'normal'));
      arr.push(peg(x, 520 + Math.sin(i*0.6)*30, i%2===0?'cursed':'normal'));
    }
    arr.push(...ring(W/2, 360, 200, 18, 'cursed'));
    return arr;
  }

  function labyrinthCage(){
    const arr=[];
    const rows=5, cols=9;
    const gapX=W/(cols+1); const gapY=70;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = gapX*(c+1);
        const y = 200 + r*gapY;
        const border = (r===0||r===rows-1||c===0||c===cols-1);
        const type = border ? ((r+c)%2===0? 'cursed':'normal') : ((r+c)%3===0? 'cursed':'normal');
        arr.push(peg(x,y,type));
      }
    }
    for(let i=0;i<6;i++){
      arr.push(peg(140 + i*120, 340 + Math.sin(i)*50, i%2===0?'steel':'normal'));
    }
    arr.push(...ring(W/2, 560, 150, 12));
    return arr;
  }

  function impactField(){
    const arr = scatterLayout(36, 0.32, 200, H-220);
    for(let i=0;i<5;i++){
      const x = 180 + i*140;
      arr.push(peg(x, 240, i%2===0?'cursed':'normal'));
      arr.push(peg(x, 500, i%3===0?'steel':'cursed'));
    }
    const core = ring(W/2, 360, 120, 10, 'cursed');
    core.forEach((p,i)=>{ if(i%3===0) p.type='steel'; });
    arr.push(...core);
    return arr;
  }

  function eclipseRun(){
    const arr=[];
    arr.push(...waveLayout(5,10,210,52,0.8));
    arr.push(...ring(W/2, 280, 80, 6, 'cursed'));
    const halo = ring(W/2, 280, 200, 14);
    halo.forEach((p,i)=>{ if(i%4===0) p.type='cursed'; });
    arr.push(...halo);
    for(let i=0;i<6;i++){
      arr.push(peg(160 + i*120, 520 + Math.cos(i*0.6)*36, i%2===0?'steel':'normal'));
    }
    return arr;
  }

  function meteorFall(){
    const arr = scatterLayout(38, 0.34, 200, H-220);
    for(let i=0;i<6;i++){
      arr.push(peg(140 + i*110, 220 + i*60, i%2===0?'cursed':'steel'));
    }
    for(let i=0;i<5;i++){
      arr.push(peg(W-140 - i*110, 260 + i*60, i%3===0?'cursed':'normal'));
    }
    arr.push(...ring(W/2, 580, 140, 14, 'cursed'));
    return arr;
  }

  function finaleCataclysm(){
    const arr=[];
    arr.push(...ring(W/2, 320, 90, 8, 'cursed'));
    const mid = ring(W/2, 320, 160, 14);
    mid.forEach((p,i)=>{
      if(i%4===0) p.type='cursed';
      if(i%6===0) p.type='steel';
    });
    arr.push(...mid);
    const outer = ring(W/2, 320, 230, 18);
    outer.forEach((p,i)=>{ if(i%3===0) p.type='steel'; });
    arr.push(...outer);
    const spokes = 8;
    for(let i=0;i<spokes;i++){
      const a = i/spokes*Math.PI*2;
      for(let k=1;k<=4;k++){
        const radius = 60 + k*60;
        const type = k===4 ? 'steel' : (k%2===0? 'cursed':'normal');
        arr.push(peg(W/2 + Math.cos(a)*radius, 320 + Math.sin(a)*radius, type));
      }
    }
    for(let i=0;i<6;i++){
      arr.push(peg(160 + i*120, 540 + Math.sin(i*0.6)*50, i%2===0?'cursed':'steel'));
    }
    arr.push(...scatterLayout(24, 0.4, 160, H-200));
    return arr;
  }

  const LEVELS = [
    introSanctum,
    crescentGates,
    ritualStar,
    whisperSpiral,
    terracedColumns,
    tidalRun,
    guardianEye,
    fractureField,
    twinSpirals,
    bulwarkHall,
    emberBloom,
    glassGarden,
    obsidianCrown,
    leviathanRise,
    voidChorus,
    labyrinthCage,
    impactField,
    eclipseRun,
    meteorFall,
    finaleCataclysm,
  ];
  const TOTAL_LEVELS = LEVELS.length;

  function loadLevel(i){
    const idx = Math.min(Math.max(1, i), TOTAL_LEVELS) - 1;
    world.level = i;
    world.pegs = LEVELS[idx]();
    world.totalCursed = world.pegs.filter(p=>p.type==='cursed').length;
    world.score = 0;
    world.clearedCursed = 0; world.ball=null; world.aim.ready=true; world.ballsLeft = Math.max(6, 12 - i);
    world.streak=0; lastStreakPing=0; world.fear = 0; world.ballType=POW.NONE; world.pierce=0; world.hallucinations=[];
    wipeScene();
    world.levelBaselineScore = 0;
    if(i===1 && settings.showTutorial && !tutorialShown){ scheduleTutorial(); }
    sting(); updateHUD();
  }

  function scheduleTutorial(){
    if(tutorialShown || !settings.showTutorial) return;
    tutorialShown = true;
    world.aim.ready = false;
    setTimeout(()=> showTutorialOverlay(), 400);
  }

  function showTutorialOverlay(){
    if(!settings.showTutorial) return;
    stateBeforePause = STATE.PLAY;
    state = STATE.PAUSE;
    world.aim.ready = false;
    const name = escHTML(settings.playerName || 'Wanderer');
    setOverlay(`<div class="menu tutorial"><div class="title">Setlist Primer</div><p>Welcome, ${name}. Three rules keep the encore alive.</p><p>1. Aim the haunted orb with your mouse and click to release.<br>2. Smash every <b>cursed red peg</b> before you run out of shots.<br>3. Catch the bucket beast to reclaim an eyeball.</p><div class="row" style="gap:12px"><button class="btn" id="tutorialSkip">✖ Skip Tutorial</button><button class="btn good" id="tutorialBegin">✔ Begin</button></div></div>`);
    document.getElementById('tutorialSkip').onclick = () => {
      settings.showTutorial = false;
      persistSettings();
      setOverlay('');
      state = STATE.PLAY;
      world.aim.ready = true;
      syncHUDVisibility();
    };
    document.getElementById('tutorialBegin').onclick = () => {
      runTutorialHints(()=>{
        state = STATE.PLAY;
        world.aim.ready = true;
        syncHUDVisibility();
      });
    };
  }

  function runTutorialHints(onDone){
    let idx = 0;
    const advance = () => {
      if(idx >= TUTORIAL_STEPS.length){
        setOverlay('');
        if(onDone) onDone();
        return;
      }
      const step = TUTORIAL_STEPS[idx];
      setOverlay(`<div class="menu hint"><div class="title">${step.title}</div><p>${escHTML(step.body)}</p><button class="btn good" id="hintNext">Continue</button></div>`);
      document.getElementById('hintNext').onclick = () => { idx++; advance(); };
    };
    advance();
  }

  // ===== Entities =====
  class Ball{
    constructor(x,y,vx,vy){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.r=14; this.dead=false; }
    step(){ this.vy += world.gravity; this.vx *= world.friction; this.vy *= world.friction; this.x += this.vx; this.y += this.vy; if(this.x < this.r){ this.x=this.r; this.vx*=-1; } if(this.x > W-this.r){ this.x=W-this.r; this.vx*=-1; } if(this.y < this.r){ this.y=this.r; this.vy*=-1; } if(this.y > H-this.r){ this.y = H-this.r; this.vy *= -0.45; this.vx *= 0.96; if(Math.abs(this.vy)<3.5) this.dead=true; } this.collidePegs(); this.collideBucket(); }
    collidePegs(){ for(const p of world.pegs){ if(p.hit) continue; const dx=this.x-p.x, dy=this.y-p.y; const d=Math.hypot(dx,dy); if(d < this.r + p.r){ const nx=dx/d, ny=dy/d; const vdot = this.vx*nx + this.vy*ny; // if skull, pierce through N pegs before bouncing
          if(world.ballType===POW.SKULL && world.pierce>0){ world.pierce--; hitPeg(p,true); continue; }
          this.vx -= 2*vdot*nx; this.vy -= 2*vdot*ny; this.x = p.x + (this.r+p.r+0.2)*nx; this.y = p.y + (this.r+p.r+0.2)*ny; hitPeg(p,false); } } }
    collideBucket(){ const b=world.bucket; if(this.y + this.r >= b.y && this.y - this.r <= b.y + b.h && this.x > b.x && this.x < b.x + b.w && this.vy>0){ this.dead=true; world.ballsLeft++; world.streak+=3; announceStreak(world.streak); world.score += 300 * (1 + Math.min(10, world.streak*0.2)); screenShake(10); tone(880,0.08,'triangle',0.05); if(settings.bloodEnabled){ sprayBlood(this.x, this.y, 0.8); } else { spawnSpectralMist(this.x, this.y, 1.4); } b.open=false; b.anim=12; if(world.ballType===POW.ROTTEN){ // restore bucket size
          b.w = 140; } } }
    draw(){ const img = world.ballType===POW.SKULL? Spr.skull : world.ballType===POW.ROTTEN? Spr.rotten : Spr.ball; ctx.drawImage(img, this.x-20, this.y-20, 40, 40); }
  }

  class Particle{
    constructor(x,y,vx,vy,life,scale,type='blood'){
      this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.life=life; this.scale=scale||1; this.type=type;
    }
    step(){ this.vy += 0.18; this.x += this.vx; this.y += this.vy; this.vx *= 0.99; this.vy *= 0.99; this.life--; }
    draw(){
      const alpha = Math.max(0, this.life/60);
      if(alpha<=0) return;
      ctx.globalAlpha = alpha;
      const s=32*this.scale;
      if(this.type==='blood'){
        ctx.drawImage(Spr.splat, this.x-s/2, this.y-s/2, s, s);
      } else {
        const grd = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, s*0.6);
        if(this.type==='ember'){
          grd.addColorStop(0,'rgba(255,215,134,0.82)');
          grd.addColorStop(1,'rgba(255,111,0,0)');
        } else {
          grd.addColorStop(0,'rgba(186,230,253,0.85)');
          grd.addColorStop(1,'rgba(56,189,248,0)');
        }
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(this.x, this.y, s*0.35, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha=1;
    }
  }

  // ===== Utilities =====
  function clearBlood(){
    world.decals = [];
    world.particles = world.particles.filter(p => p.type !== 'blood');
  }
  function wipeScene(){
    world.decals = [];
    world.particles = [];
  }
  function sprayBlood(x,y,scale=1){
    if(!settings.bloodEnabled) return;
    const count = Math.floor(18*quality.mul*scale);
    for(let i=0;i<count;i++) world.particles.push(new Particle(x, y, (Math.random()*2-1)*4.6, (Math.random()*2-1)*4.2, 36+Math.random()*30, .6+Math.random()*0.8, 'blood'));
    for(let i=0;i<Math.floor(4*quality.mul*scale);i++) addDecal(x+(Math.random()*2-1)*16, y+(Math.random()*2-1)*16);
  }
  function spawnSpectralMist(x,y,scale=1){
    const count = Math.floor(12*quality.mul*scale);
    const type = (settings.fearEffects && currentFearStage>=3)? 'ember':'wisp';
    for(let i=0;i<count;i++) world.particles.push(new Particle(x, y, (Math.random()*2-1)*3.2, (Math.random()*2-1)*3.2, 40+Math.random()*24, .6+Math.random()*0.5, type));
  }
  function maybeTriggerJumpscare(){ if(jumpscareActive || !settings.fearEffects) return; if(world.fear < 85 || jumpscareCooldown>0) return; if(Math.random()<0.18){ triggerJumpscare(); } }
  function triggerJumpscare(){
    jumpscareActive = true;
    jumpscareCooldown = 600;
    screenShake(26);
    subBoom();
    noise(260, .32);
    tone(1400,0.08,'sawtooth',0.07);
    tone(320,0.25,'square',0.05);
    const layer=document.createElement('div'); layer.className='jumpscare-layer active';
    const face=document.createElement('div'); face.className='jumpscare-face';
    const eyeL=document.createElement('div'); eyeL.className='jumpscare-eye left';
    const eyeR=document.createElement('div'); eyeR.className='jumpscare-eye right';
    const mouth=document.createElement('div'); mouth.className='jumpscare-mouth';
    const tag=document.createElement('div'); tag.className='jumpscare-text';
    const messages=['DO NOT BLINK','IT SEES YOU','FEED THE FEAR','STAY IN THE LIGHT'];
    tag.textContent = messages[Math.floor(Math.random()*messages.length)];
    face.append(eyeL, eyeR, mouth, tag);
    layer.appendChild(face);
    document.body.appendChild(layer);
    document.body.classList.add('fear-flash');
    setTimeout(()=>{ document.body.classList.remove('fear-flash'); }, 600);
    setTimeout(()=>{ layer.remove(); jumpscareActive=false; }, 900);
  }
  function rect(x,y,w,h,fill){ ctx.fillStyle=fill; ctx.fillRect(x,y,w,h); }
  function screenShake(a){ world.screenShake = Math.max(world.screenShake, a); }
  function addDecal(x,y){ if(!settings.bloodEnabled) return; world.decals.push({x,y, s: (24+Math.random()*36)*quality.mul, rot: Math.random()*Math.PI}); if(world.decals.length>Math.floor(240*quality.mul)) world.decals.shift(); }

  // ===== Effects & Hits =====
  function dropPowerupChance(px, py){ if(Math.random()<0.2){ // 20% on cursed hits
      const type = Math.random()<0.5? POW.SKULL : POW.ROTTEN; const pow = POW_DATA[type]; showFloat(`Power: ${pow.label}`, px, py, { color:pow.color, glow:'#38bdf8', fontSize:18, duration:90, rise:1 }); world.ballType = type; if(type===POW.SKULL){ world.pierce = 3; } else if(type===POW.ROTTEN){ world.bucket.w = Math.max(80, world.bucket.w*0.6); }
      updateHUD();
    } }

  function hitPeg(p, pierce){ if(p.type==='steel'){ noise(90,.18); screenShake(3); world.streak=0; lastStreakPing=0; world.score+=5; return; } p.hit = true; world.streak++; announceStreak(world.streak); world.score += 60 + world.streak*12; noise(120,.22); screenShake(6); world.fear = Math.min(100, world.fear + 1 + Math.random()*1.8); maybeTriggerJumpscare(); const scale = p.type==='cursed'? 1.25 : 1; if(settings.bloodEnabled){ sprayBlood(p.x, p.y, scale); if(p.type==='cursed') spawnSpectralMist(p.x, p.y, 0.6); } else { spawnSpectralMist(p.x, p.y, scale); } if(p.type==='cursed'){ world.clearedCursed++; tone(240,0.08,'sawtooth',0.05); dropPowerupChance(p.x,p.y); if(settings.fearEffects){ if(world.fear>60 && Math.random()<0.35) whisper(); if(world.fear>70) { subBoom(); } } }
    if(!pierce && world.ballType===POW.SKULL && world.pierce<=0){ // skull used up
      world.ballType = POW.NONE; updateHUD();
    }
  }

  function showFloat(text,x,y,opts={}){
    const { color='#facc15', glow='#f43f5e', duration=60, rise=1.2, scale=1, fontSize=16, fontWeight=700, className='' } = opts;
    const div=document.createElement('div');
    div.textContent=text;
    div.className = className;
    div.style.cssText=`position:absolute;left:${x}px;top:${y}px;transform:translate(-50%,-50%) scale(${scale});font-weight:${fontWeight};font-size:${fontSize}px;color:${color};text-shadow:0 0 12px ${glow};pointer-events:none;`; ui.appendChild(div);
    let t=0;
    const id=setInterval(()=>{
      t++;
      div.style.top = (y - t*rise)+'px';
      div.style.opacity = Math.max(0, 1 - t/duration);
      if(t>duration){ clearInterval(id); div.remove(); }
    }, 16);
    return div;
  }

  function announceStreak(streak){
    if(streak<=1 || lastStreakPing===streak) return;
    const important = STREAK_MILESTONES.includes(streak) || (streak>=30 && streak%5===0);
    if(!important) return;
    lastStreakPing = streak;
    showFloat(`Streak ×${streak}`, W/2, 120, { color:'#fde68a', glow:'#f97316', fontSize:22, duration:72, rise:1.3, scale:1.1 });
  }

  // ===== Input =====
  const mouse = {x: W/2, y: 60, down:false};
  canvas.addEventListener('mousemove', e=>{ const r=canvas.getBoundingClientRect(); mouse.x = e.clientX-r.left; mouse.y = e.clientY-r.top; const dx = mouse.x - W/2, dy = mouse.y - 60; world.aim.ang = Math.atan2(dy,dx); world.aim.power = Math.min(20, Math.hypot(dx,dy)/30 + 8); });
  canvas.addEventListener('mousedown', ()=>{ mouse.down=true; if(state===STATE.PLAY) fire(); else if(state===STATE.MENU) startGame(); else if(state===STATE.BOOT) bootProg=100; });
  window.addEventListener('mouseup', ()=> mouse.down=false);
  window.addEventListener('keydown', (e)=>{
    if(e.code==='Space'){
      if(ui.querySelector('.menu.story, .menu.tutorial')) return;
      if(state===STATE.MENU && document.getElementById('playBtn')) startGame();
      else if(state===STATE.PLAY) fire();
      else if(state===STATE.BOOT) bootProg=100;
    }
    if(e.key==='Escape'){
      if(settingsOpen) closeSettings();
      else if(state===STATE.PLAY) openSettings();
    }
    if(e.code==='KeyA' && e.ctrlKey && e.shiftKey){
      settings.adminUnlocked = !settings.adminUnlocked;
      persistSettings();
      const note = settings.adminUnlocked? 'Admin tools unlocked' : 'Admin tools disabled';
      showFloat(note, W/2, H/2, { color:'#facc15', glow:'#fbbf24', duration:90, rise:0, scale:1.2 });
    }
  });

  function fire(){ if(!world.aim.ready || world.ballsLeft<=0) return; const a = world.aim.ang; const p = world.aim.power; world.ball = new Ball(W/2, 60, Math.cos(a)*p, Math.sin(a)*p); world.ballsLeft--; world.aim.ready=false; tone(520,0.06,'square',0.045); updateHUD(); }

  // ===== Bucket =====
  function stepBucket(){ const b=world.bucket; b.x += b.vx; if(b.x<20||b.x+b.w>W-20){ b.vx*=-1; } if(b.anim>0){ b.anim--; if(b.anim<=0){ b.open=true; } } }
  function drawBucket(){ const b=world.bucket; const spr = b.open? Spr.bucketOpen : Spr.bucketClosed; ctx.drawImage(spr, b.x, b.y, b.w, b.h); }

  // ===== UI Screens =====
  function setOverlay(html){
    ui.innerHTML = html||'';
    ui.style.pointerEvents = html ? 'auto' : 'none';
    syncHUDVisibility();
  }
  function showBoot(){ setOverlay(`<div class="menu"><div class="title">Evil Peggle</div><div class="subtitle" id="bootMsg">${bootMsgs[0]}</div><div class="progress-bar" style="width:320px"><i id="bootFill" style="transform:scaleX(0)"></i></div><div class="warn">Content warning: flashing lights, jumpscares, and stylized gore. Headphones recommended.</div><div class="flash" style="margin-top:10px">PRESS SPACE</div></div>`); }
  function tickBoot(){ bootProg = Math.min(100, bootProg + 1.5 + Math.random()*1.5); const fill=document.getElementById('bootFill'); const msg=document.getElementById('bootMsg'); if(fill) fill.style.transform = `scaleX(${bootProg/100})`; if(msg && bootProg>bootMsgIdx*20){ bootMsgIdx=(bootMsgIdx+1)%bootMsgs.length; msg.textContent = bootMsgs[bootMsgIdx]; } if(bootProg>=100){ enterAttract(); } }
  function enterAttract(){ ensurePlayerName(()=> startMenu()); }

  function ensurePlayerName(done){
    const current = (settings.playerName||'').trim();
    if(current && current !== 'Wanderer'){
      if(typeof done === 'function') done();
      return;
    }
    stopGame();
    state = STATE.MENU;
    const defaultVal = current && current !== 'Wanderer'? current : '';
    setOverlay(`<div class="menu name"><div class="title">State Your Name</div><p>Whisper the alias the carnival will chant.</p><input id="playerNameInputPrimary" maxlength="16" value="${escHTML(defaultVal)}" autocomplete="off" placeholder="Wanderer" /><small>Only letters, numbers, spaces, - _ !</small><div class="row" style="gap:10px"><button class="btn good" id="nameConfirm">✔ Enter</button><button class="btn" id="nameSkip">Skip</button></div></div>`);
    const input = document.getElementById('playerNameInputPrimary');
    const sanitize = (val)=> val.replace(/[^a-z0-9 _!\-]/gi,'').slice(0,16);
    if(input){
      input.focus();
      input.addEventListener('input', (e)=>{ e.target.value = sanitize(e.target.value); });
      input.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ document.getElementById('nameConfirm')?.click(); }});
    }
    const commit = (raw)=>{
      const value = sanitize(raw).trim();
      settings.playerName = value || 'Wanderer';
      persistSettings();
      refreshPlayerBadge();
      setOverlay('');
      if(typeof done === 'function') done();
    };
    document.getElementById('nameConfirm')?.addEventListener('click', ()=> commit(input?.value||''));
    document.getElementById('nameSkip')?.addEventListener('click', ()=> commit('Wanderer'));
  }

  function showStoryIntro({ markSeen=false, onComplete }={}){
    stopGame();
    state = STATE.MENU;
    const name = escHTML(settings.playerName || 'Wanderer');
    const slides = [
      { title:'Backstage Note', body:[`${name}, the headliner’s gone and the crowd is restless.`, 'Each cursed peg holds the chorus hostage — crack them to keep the show alive.'] },
      { title:'Encore Rules', body:['Launch the haunted eyeball and clear every crimson peg before you run out of shots.', 'Catch the bucket beast to recover a ball. Miss, and the pit will swallow you.'] },
      { title:'Fear Meter', body:['Streaks fuel the Fear bar. Higher fear twists the arena with lights, whispers, and power.', 'Stay focused. The band’s finale depends on your aim.'] }
    ];
    const total = slides.length;
    let idx = 0;
    const finish = () => {
      if(markSeen){ settings.storySeen = true; persistSettings(); }
      setOverlay('');
      if(typeof onComplete === 'function'){ onComplete(); }
      else { startMenu(); }
    };
    const render = () => {
      const slide = slides[idx];
      const paragraphs = slide.body.map(line => `<p>${escHTML(line)}</p>`).join('');
      const progress = `<div class="story-progress">${idx+1} / ${total}</div>`;
      const isLast = idx === total-1;
      setOverlay(`<div class="menu story"><div class="title">${slide.title}</div>${progress}${paragraphs}<div class="row" style="gap:12px"><button class="btn" id="storySkip">✖ Skip</button><button class="btn good" id="storyNext">${isLast? '✔ Begin':'▶ Next'}</button></div></div>`);
      document.getElementById('storySkip').onclick = finish;
      document.getElementById('storyNext').onclick = () => {
        if(isLast){ finish(); }
        else { idx++; render(); }
      };
    };
    render();
  }

  function startMenu(){
    if(state===STATE.PLAY && gameMode===MODE.STORY){
      settings.storyProgress = Math.max(1, Math.min(TOTAL_LEVELS, world.level));
      persistSettings();
    }
    stopGame();
    state=STATE.MENU;
    gameMode = MODE.STORY;
    const hint = MENU_HINTS[Math.floor(Math.random()*MENU_HINTS.length)];
    const scoreHtml = renderScoreList();
    const freeplayLocked = !settings.storyCleared && settings.storyProgress <= 1;
    const freeplayButton = freeplayLocked
      ? '<button class="btn" id="freeplayBtn" disabled title="Finish Story Run to unlock">🔒 Freeplay</button>'
      : '<button class="btn" id="freeplayBtn">🎯 Freeplay</button>';
    const lockNote = freeplayLocked? '<div class="warn" style="font-size:11px">Beat level 1 in Story Run to unlock Freeplay.</div>' : '';
    const resumeLabel = settings.storyProgress>1 && settings.storyProgress<=TOTAL_LEVELS? `Continue (Level ${settings.storyProgress})` : '▶ Story Run';
    setOverlay(`<div class="menu"><div class="title">Evil Peggle</div><div class="subtitle">Choose your torment</div><div class="row" style="gap:10px"><button class="btn play good" id="playBtn">${resumeLabel}</button>${freeplayButton}<button class="btn" id="loreBtn">ℹ How to Play</button></div><div class="score-list-title">Personal Best</div>${scoreHtml}${lockNote}<div class="warn">${hint}</div><div class="flash">PRESS SPACE</div></div>`);
    document.getElementById('playBtn').onclick=()=> startGame();
    const freeBtn=document.getElementById('freeplayBtn');
    if(freeBtn && !freeplayLocked) freeBtn.onclick = () => showFreeplayMenu();
    const loreBtn=document.getElementById('loreBtn');
    if(loreBtn) loreBtn.onclick = () => showStoryIntro({ markSeen:false, onComplete:startMenu });
  }
  function startGame(){
    stopGame();
    gameMode = MODE.STORY;
    const canResume = settings.storyProgress>1 && settings.storyProgress<=TOTAL_LEVELS;
    state=STATE.PLAY;
    setOverlay('');
    tutorialShown = false;
    if(canResume){
      loadLevel(settings.storyProgress);
    } else {
      world.score = 0;
      settings.storyProgress = 1;
      persistSettings();
      loadLevel(1);
    }
    updateHUD();
    world.aim.ready=true;
    syncHUDVisibility();
  }

  function showFreeplayMenu(){
    stopGame();
    state=STATE.MENU;
    world.aim.ready=false;
    const unlockedCount = settings.storyCleared ? TOTAL_LEVELS : Math.max(0, Math.min(TOTAL_LEVELS, settings.storyProgress - 1));
    if(unlockedCount<=0){
      setOverlay(`<div class="menu"><div class="title">Freeplay Locked</div><div class="subtitle">Beat a level in Story Run first</div><button class="btn" id="lockedBack">← Back</button></div>`);
      document.getElementById('lockedBack')?.addEventListener('click', ()=> startMenu());
      return;
    }
    const cards = Array.from({length: unlockedCount}, (_,i)=>{
      const level=i+1;
      return `<button type="button" class="score-card" data-level="${level}">Level ${level}<span>Best ${formatScore(getBestScore(level))}</span></button>`;
    }).join('');
    const totalNote = unlockedCount < TOTAL_LEVELS && !settings.storyCleared ? `<div class="warn" style="font-size:11px">Clear more Story levels to unlock additional Freeplay hunts.</div>` : '';
    setOverlay(`<div class="menu"><div class="title">Freeplay</div><div class="subtitle">Pick a level to replay</div><div class="score-list" style="max-height:240px;width:100%;max-width:420px;overflow:auto">${cards}</div>${totalNote}<div class="row" style="gap:10px"><button class="btn" id="freeplayBack">← Back</button></div></div>`);
    document.querySelectorAll('.score-card').forEach(btn=>{
      btn.onclick = ()=> startFreeplay(Number(btn.dataset.level));
    });
    const back=document.getElementById('freeplayBack');
    if(back) back.onclick = () => startMenu();
  }

  function startFreeplay(level){
    freeplayLevel = level;
    gameMode = MODE.FREEPLAY;
    tutorialShown = true;
    world.score = 0;
    state = STATE.PLAY;
    setOverlay('');
    loadLevel(level);
    updateHUD();
    world.aim.ready = true;
    syncHUDVisibility();
  }

  function showFreeplayResult(levelScore){
    stopGame();
    state = STATE.MENU;
    world.aim.ready = false;
    const best = formatScore(getBestScore(freeplayLevel));
    setOverlay(`<div class="menu"><div class="title">Level ${freeplayLevel} Cleared</div><div class="subtitle">Score ${formatScore(levelScore)}</div><div class="warn">Personal best: ${best}</div><div class="row" style="gap:10px"><button class="btn good" id="freeplayReplay">↺ Encore</button><button class="btn" id="freeplaySelect">🎯 Levels</button><button class="btn" id="freeplayMenu">☰ Menu</button></div></div>`);
    document.getElementById('freeplayReplay').onclick = () => startFreeplay(freeplayLevel);
    document.getElementById('freeplaySelect').onclick = () => showFreeplayMenu();
    document.getElementById('freeplayMenu').onclick = () => startMenu();
  }
  function showGameOver(){
    stopGame();
    const final = Math.floor(world.score);
    settings.storyProgress = 1;
    persistSettings();
    setOverlay(`<div class="menu"><div class="title">Crowd Booed You Off</div><div class="subtitle">Final score <b>${final}</b> · Level ${world.level}</div><div class="row" style="gap:10px"><button class="btn good" id="retryBtn">↺ Encore</button><button class="btn" id="menuBtn">☰ Backstage</button></div></div>`);
    document.getElementById('retryBtn').onclick=()=>{ setOverlay(''); state=STATE.PLAY; world.score=0; settings.storyProgress=1; persistSettings(); loadLevel(1); updateHUD(); world.aim.ready=true; syncHUDVisibility(); };
    document.getElementById('menuBtn').onclick=()=> startMenu();
  }

  function showStoryComplete(finalScore){
    stopGame();
    state = STATE.MENU;
    settings.storyCleared = true;
    settings.storyProgress = 1;
    persistSettings();
    const formatted = formatScore(finalScore);
    setOverlay(`<div class="menu"><div class="title">Encore Complete</div><div class="subtitle">Total score <b>${formatted}</b></div><div class="warn">Freeplay unlocked! Revisit any haunt for better scores.</div><div class="row" style="gap:10px"><button class="btn good" id="storyReplay">▶ Replay Story</button><button class="btn" id="storyFreeplay">🎯 Freeplay</button><button class="btn" id="storyMenu">☰ Menu</button></div></div>`);
    document.getElementById('storyReplay').onclick = () => startGame();
    document.getElementById('storyFreeplay').onclick = () => showFreeplayMenu();
    document.getElementById('storyMenu').onclick = () => startMenu();
  }

  function showFreeplayLoss(){
    stopGame();
    state = STATE.MENU;
    world.aim.ready=false;
    const levelScore = Math.max(0, Math.floor(world.score));
    const best = formatScore(getBestScore(freeplayLevel));
    setOverlay(`<div class="menu"><div class="title">Encore Failed</div><div class="subtitle">Level ${freeplayLevel} · Score ${formatScore(levelScore)}</div><div class="warn">Personal best: ${best}</div><div class="row" style="gap:10px"><button class="btn good" id="freeplayEncore">↺ Encore</button><button class="btn" id="freeplayLevels">🎯 Levels</button><button class="btn" id="freeplayMenuLoss">☰ Menu</button></div></div>`);
    document.getElementById('freeplayEncore').onclick = () => startFreeplay(freeplayLevel);
    document.getElementById('freeplayLevels').onclick = () => showFreeplayMenu();
    document.getElementById('freeplayMenuLoss').onclick = () => startMenu();
  }

  // ===== Draw helpers =====
  function drawBG(){
    ctx.drawImage(Spr.bg, 0, 0, W, H);
    const flick = 0.05 + Math.sin(Date.now()*0.0023)*0.025;
    ctx.save();
    ctx.globalAlpha = flick;
    const flare = ctx.createRadialGradient(W/2, 70, 60, W/2, 70, 460);
    flare.addColorStop(0, 'rgba(239,68,68,.38)');
    flare.addColorStop(0.45, 'rgba(127,29,29,.22)');
    flare.addColorStop(1, 'rgba(0,0,0,0)');
    rect(0, 0, W, H, flare);
    ctx.globalAlpha = 0.28 * flick;
    const abyss = ctx.createLinearGradient(0, H*0.55, 0, H);
    abyss.addColorStop(0, 'rgba(12,0,20,0)');
    abyss.addColorStop(1, 'rgba(5,0,12,.65)');
    rect(0, 0, W, H, abyss);
    if(currentFearStage>=3){
      const bands = currentFearStage===3? 3 : 5;
      ctx.globalAlpha = 0.05 + (currentFearStage-2)*0.04;
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      for(let i=0;i<bands;i++){
        const h = 4 + Math.random()*8;
        const y = Math.random()*H;
        ctx.fillRect(0, y, W, h);
      }
    }
    ctx.restore();
  }
  function drawDecals(){
    if(!settings.bloodEnabled) return;
    for(const d of world.decals){ ctx.save(); ctx.globalAlpha=.8; ctx.translate(d.x, d.y); ctx.rotate(d.rot); ctx.drawImage(Spr.splat, -d.s/2, -d.s/2, d.s, d.s); ctx.restore(); }
  }
  function drawPegs(){ const t=Date.now()*0.008; for(const p of world.pegs){ if(p.hit) continue; const wob = Math.sin(p.t + t)* (p.type==='cursed'? 1.5:0.6); const img = p.type==='cursed'? (Math.sin(t*3+p.t)>0? Spr.cursedA: Spr.cursedB) : (p.type==='steel'? Spr.steel : Spr.meat); ctx.drawImage(img, p.x-22+wob, p.y-22, 44, 44); } }
  function drawHallucinations(){ if(!settings.fearEffects || world.fear<60) return; const count = Math.min(10, Math.floor((world.fear-60)/4)); // generate positions if needed
    while(world.hallucinations.length<count){ world.hallucinations.push({x:Math.random()*W, y:120+Math.random()*(H-220), r:20, t:Math.random()*100}); }
    ctx.save(); ctx.globalAlpha = 0.28 + Math.random()*0.12; for(const h of world.hallucinations){ const wob=Math.sin(h.t + Date.now()*0.008)*1.2; ctx.drawImage(Spr.cursedA, h.x-22+wob, h.y-22, 44, 44); } ctx.restore(); }
  function drawAimer(){
    if(!world.aim.ready) return;
    const a=world.aim.ang; const p=world.aim.power; const tx=W/2+Math.cos(a)*p*5, ty=60+Math.sin(a)*p*5;
    const readyImg = world.ballType===POW.SKULL? Spr.skull : world.ballType===POW.ROTTEN? Spr.rotten : Spr.ball;
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.drawImage(readyImg, W/2-20, 36, 40, 40);
    if(world.fear>70){ ctx.filter='contrast(140%) saturate(120%) blur(1px)'; }
    ctx.setLineDash([6,6]);
    ctx.lineDashOffset = - (Date.now()*0.05 % 12);
    ctx.beginPath();
    ctx.moveTo(W/2, 60);
    ctx.lineTo(tx, ty);
    ctx.strokeStyle='#f43f5e';
    ctx.lineWidth=2;
    ctx.stroke();
    ctx.filter='none';
    ctx.restore();
  }

  function getFearStage(value){
    for(let i=FEAR_STAGES.length-1;i>=0;i--){ if(value >= FEAR_STAGES[i].threshold) return i; }
    return 0;
  }

  function setFearStage(stage){
    const prev = currentFearStage;
    const meta = FEAR_STAGES[stage] || FEAR_STAGES[0];
    if(stage === prev){
      if(fearStageLabel) fearStageLabel.textContent = meta.label;
      return;
    }
    currentFearStage = stage;
    if(fearWidget){
      FEAR_STAGES.forEach((s,idx)=> fearWidget.classList.toggle(s.className, idx===stage));
    }
    if(fearStageLabel){ fearStageLabel.textContent = meta.label; }
    document.body.dataset.fear = stage;
    if(stage > prev && prev >= 0 && settings.fearEffects){
      showFloat(`FEAR: ${meta.label}`, W/2, 90, { color:'#fecdd3', glow:'#f472b6', fontSize:20, duration:80, rise:1.1, scale:1.05 });
      if(stage>=4) maybeTriggerJumpscare();
      if(stage>=2) whisper();
      if(stage>=4) subBoom();
    }
  }

  function updateHUD(){
    ballsLabel.textContent = world.ballsLeft;
    scoreLabel.textContent = Math.floor(world.score);
    if(streakLabel) streakLabel.textContent = world.streak;
    if(cursedLabel) cursedLabel.textContent = `${Math.max(0, world.totalCursed - world.clearedCursed)} / ${world.totalCursed||0}`;
    levelLabel.textContent = world.level;
    const fearPct = Math.round(world.fear);
    fearLabel.textContent = fearPct + '%';
    if(fearFill){ fearFill.style.transform = `scaleX(${Math.min(1, Math.max(0, fearPct/100))})`; }
    setFearStage(getFearStage(fearPct));
    const powMeta = POW_DATA[world.ballType] || POW_DATA[POW.NONE];
    let powerText = powMeta.short;
    if(world.ballType===POW.SKULL){ powerText += ` ×${world.pierce}`; }
    if(powerLabel){
      powerLabel.textContent = powerText;
      powerLabel.style.color = powMeta.color;
      powerLabel.style.opacity = world.ballType===POW.NONE? 0.7 : 1;
      powerLabel.title = `${powMeta.label}${powMeta.desc? ` — ${powMeta.desc}`:''}`;
    }
    const prog = world.totalCursed? world.clearedCursed/world.totalCursed : 0;
    progressFill.style.transform = `scaleX(${Math.min(1, Math.max(0, prog))})`;
  }

  function checkEnd(){
    if(world.clearedCursed >= world.totalCursed){
      sting();
      const k = Math.floor(220*quality.mul);
      const type = settings.bloodEnabled? 'blood' : 'ember';
      for(let i=0;i<k;i++) world.particles.push(new Particle(W/2, H-120, (Math.random()*2-1)*6, -Math.random()*5-2, 60+Math.random()*40, .8+Math.random()*0.8, type));
      world.score += 1200 + world.ballsLeft*140;
      const levelScore = Math.max(0, Math.floor(world.score));
      recordBest(world.level, levelScore);
      updateHUD();
      if(gameMode === MODE.STORY){
        settings.storyProgress = world.level;
        persistSettings();
      }
      if(gameMode === MODE.FREEPLAY){
        world.ball = null;
        showFreeplayResult(levelScore);
      } else {
        world.level++;
        if(world.level > TOTAL_LEVELS){
          showStoryComplete(Math.floor(world.score));
        } else {
          loadLevel(world.level);
        }
      }
    } else if(world.ball?.dead){
      world.ball=null;
      world.aim.ready=true;
      world.streak=0;
      lastStreakPing=0;
      if(world.ballsLeft<=0){
        if(gameMode === MODE.FREEPLAY){
          showFreeplayLoss();
        } else {
          state=STATE.GAMEOVER; showGameOver();
        }
      }
    }
  }

  function withShake(draw){ if(world.screenShake>0){ world.screenShake*=0.9; const s=world.screenShake; const dx=(Math.random()*2-1)*s, dy=(Math.random()*2-1)*s; ctx.save(); ctx.translate(dx,dy); draw(); ctx.restore(); } else draw(); }

  // ===== Loop =====
  function loop(){ requestAnimationFrame(loop);
    if(state===STATE.BOOT){ drawBG(); tickBoot(); return; }
    if(state===STATE.MENU){ drawBG(); return; }
    if(state===STATE.PAUSE){
      withShake(()=>{ drawBG(); drawHallucinations(); drawDecals(); drawBucket(); drawPegs(); world.ball?.draw(); drawAimer(); });
      updateHUD();
      return;
    }
    withShake(()=>{ if(world.fear>70) ctx.filter='contrast(140%) saturate(115%) blur(1px)'; drawBG(); ctx.filter='none'; drawHallucinations(); drawDecals(); stepBucket(); drawBucket(); drawPegs(); world.ball?.step(); for(let i=world.particles.length-1;i>=0;i--){ const pt=world.particles[i]; pt.step(); pt.draw(); if(pt.life<=0 || pt.y>H+60) world.particles.splice(i,1); } world.ball?.draw(); drawAimer(); });
    if(state===STATE.PLAY){ if(world.fear>0){ const stage = getFearStage(world.fear); const decay = Math.max(0.004, 0.012 - stage*0.0025); world.fear = Math.max(0, world.fear - decay); } checkEnd(); }
    updateHUD();
    if(jumpscareCooldown>0) jumpscareCooldown--;
  }

  // ===== Reset/Button actions =====

  // ===== Boot & start =====
  showBoot();
  setInterval(()=>{ if(state===STATE.BOOT) tickBoot(); }, 40);
  loop();
})();
</script>
</body>
</html>
